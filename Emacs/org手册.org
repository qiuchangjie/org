#+TITLE: Org-Manual 7.8
#+AUTHOR: DarkSun
#+OPTIONS: ^:{}
* 总介 ([[https://github.com/marboo/orgmode-cn][作者 github 地址]])
** 摘要            : org 大概能够做什么的摘要
   Org 是一种通过纯文本方式来快速而有效地记录笔记,处理待办列表,做项目计划的 mode.
   
   Org 通过一些 NOTE 文件来组织任务,这些 NOTE 文件用纯文本的方式包含了一些列的项目信息. Org 是建立在 Outline mode 的基础之上的,Outline mode 能够很好地组织大型文件的内容. 你可以使用可视的循环和结构编辑功能来帮助你编辑大纲树结构. 通过使用内置的表格编辑器,你也可以很容易地创建出一个表格. Org 可以管理代办列表,设置最后期限,加时间戳,制定规划. 它动态的把这些东西显示在一个 agenda 中,在这个 agenda 中很好地集成了 Emacs calendar 和 diary 功能. 你可以用纯文本的方式记录各种类 URL 的连接,这些连接可以链接到网站,email,Usenet 消息,BBDB(The insidious Big Brother Database)条目,和任何与项目有关的文件. 如果你想打印和分享这些记录,你可以把 org 导出为结构化的 ASCII 文件,比如 HTML,或者 iCalendar 文件(仅限于 TODO 和日程条目). 它也可以作为发布工具,为一堆的相互链接的网页提供发布服务.

   作为一个项目计划的环境,Org 通过为大纲节点增加元数据的方式工作. 正是基于这些元数据,我们可以通过查询抽取特定的记录并且动态地创建 agenda 视图.

   Org 模式中也可以包含其他非 org 环境,这些环境运行你编辑文件中的内嵌源代码,更便利地执行代码,记录文档,进行文学化编程.

   通过激活 Orgtbl mode,任何 major mode 都能拥有 Org 的表格编辑功能,这些表格编辑功能不仅自动化,上下文敏感,而且具有电子表格(spreadsheet)的运算能力. 通过一个转换步骤,就可以用它来包含一个表格到任意文件类型中(比如 LaTeX). 通过 minor Orgstruct mode,可以在非 Org mode 中使用 Org 的结构编辑和列表创建功能.

   Org 保持简单的事情简单化. 当第一次使用它时,感觉它就是个简单易用的大纲编辑器. 它不强加给你复杂性,但是当你需要的时候,却会发现有大量的功能可以使用. Org 就是一个工具盒,你可以为了不同的目的,通过的不同的途径来使用它,例如你可以把它看成是:
   #+BEGIN_EXAMPLE     
     • 一个具有可见性的转换和结构编辑能力的 outline mode 扩展
     • 一个记录结构化记录的 ASCII 系统和表格编辑器
     • 一个 TODO 列表的编辑器
     • 一个完整的日程表和计划规划工具,你可以设定工作的最后截止日期和规划执行日期.
     • 一个 GTD 系统
     • 一个简单的超文本系统,可以导出 HTML 和 LaTeX 格式的文件
     • 一个发布工具,可以用来创建一套相互链接的网页
     • 一个进行文学化编程的环境
   #+END_EXAMPLE

   有一个网站提供了最新版本的 Org 连接,还有附加信息,FAQ,和入门指导.这个网页就是 http://orgmode.org
** 安装            : 下载 org 后,如何安装
   *注意*:如果你使用的是 Emacs 或者 XEmacs 中自带的 Org 版本,请跳过这一步直接前往[[Activition][激活]]. 如果需要查看你 Emacs 中自带的 Org 是什么版本的,按下 /M-x load-library RET org/ 然后再 /M-x org-version/.

   如果你从网站上下载了 Org,不管它是 zip 还是 tar 格式的分发包,也不管它是不是 Git 存档,你必须遵照下面的步骤来安装它:
   解压 Org 分发包并进入解压的目录中,然后编辑顶层目录中的'Makefile'文件. 你必须设置 Emacs 的二进制执行文件的名字(一般是'emacs'或者'xemacs'),设置 Lisp 和 Info 文件存放的路径. 如果你没有权限访问全系统的目录,你只需要简单地把'lisp'子目录加入 Emacs 的 load-path 中,然后就可以运行 org mode 了.如果你用这种方法,需要把下面这一行加入'.emacs'文件中
   #+BEGIN_SRC emacs-lisp    
     (setq load-path (cons "~/path/to/orgdir/lisp" load-path))          
   #+END_SRC
   如果你想使用'contrib'子目录中的代码,你只需要加这么一句
   #+BEGIN_SRC emacs-lisp
        (setq load-path (cons "~/path/to/orgdir/contrib/lisp" load-path))
   #+END_SRC
   现在用下面的 shell 命令来把 lisp 文件编译为字节格式
   #+BEGIN_SRC sh
     make
   #+END_SRC
   如果你只是从发布目录运行 Org,这就是所有的步骤了. 如果你想要安装 Org 到系统目录中,指向下面命令(需要系统管理员权限)
   #+BEGIN_SRC sh
     make install
   #+END_SRC
   安装 Info 文件是系统依赖的,不同的系统使用的是不同的'install-info'程序. 下面的命令理论上应该可以正确的安装 Info 文件到大多数系统中,但如果没有正确的安装的话,欢迎发送 BUG 报告给我们[fn:1]
   #+BEGIN_SRC sh
     make install-info
   #+END_SRC
   然后把下面一行添加到'.eamcs'文件中. 这使得 Emacs 可以在需要的时候自动加载文件中的函数,而不用在 Org mode 已启动的时候就加载
   #+BEGIN_SRC emacs-lisp
     (require 'org-install)
   #+END_SRC
   不要忘了激活 Org,具体操作见下一节.
** 激活            : 如何为指定的 buffer 激活 org 模式 #<<Activition>>
   为了保证后缀为'.org'的文件会使用 Org mode,在'.emacs'文件中增加下面一行
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
   #+END_SRC
   Org-mode 缓冲区需要打开 font-lock 选项,默认情况下 Emacs 已经打开次选项[fn:2]. 有 4 个 Org 命令应该定义全局的快捷键(也就是说作用于在 Emacs 的任何地方,而不仅仅是 Org 缓存区),这四个 org 命令为'org-store-link','org-capture','org-agenda'和'org-iswitchb'. 下面是建议的绑定键设置,你可以按照自己喜欢的来修改键配置
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cb" 'org-iswitchb)
   #+END_SRC
   
   经过上面这些配置,所有后缀为'.org'的文件在打开时会直接进入 Org-mode. 如果你想不这么配置,作为替代,把下面这句放到文件的一行也可以.
   #+BEGIN_EXAMPLE
     MY PROJECTS    -*- mode: org; -*-
   #+END_EXAMPLE
   这样,不管文件名是什么,在打开时都会进去 Org-mode. 参见变量'org-insert-mode-line-in-empty-file'.

   很多 Org 命令在选定文本块时会对文本块进行操作. 为了保证该特性被启用,你需要开启'transient-mark-mode'(在 XEmacs 总是'zmacs_regions'). 在 Emacs23 中默认是打开的,但是在 Emacs22 中,你需要自己打开,自己打开的命令为
   #+BEGIN_SRC emacs-lisp
     (transient-mark-mode 1)
   #+END_SRC
   
   如果你不想使用 transient-mark-mode,你可以通过鼠标选择一个区域,以这种方式来建立一个选定的文本块,或者在一定光标之前安两下'C-<SPC>'
** 反馈            : BUG 报告,好的想法,补丁等等
   如果你发现了 Org 有问题,或者你有疑问,建议和好的想法,请发邮件到 Org 的 mailing list [[emacs-orgmode@gnu.org]]. 如果你还不是这个 mailing list 的会员, 那么在版主批准之后,你的 mail 会被加入到 mailing list 中[fn:3]. 

   如果你想报告 BUG,请首先在最新版本的 Org 上复现这个 BUG--如果你允许一个老旧版本的 Org,很可能这个 Bug 已经被修复了. 如果依旧有问题,请写好报告并提供尽可能多的信息,包括 Emacs 的版本信息(用 M-x emacs-version <RET>)和 Org 的版本信息(用 M-x org-version <RET>),以及'.emacs'中 Org 的相关配置. 最简单的提交报告的方法就是执行命令'M-x org-submit-bug-report'. 这个命令会收集所有必要的信息并放到一个 Emacs 的 mail 缓存区中,这样你只需要添加你自己的描述就可以了. 如果你不会在 Emacs 中发送 email,请拷贝这些内容并粘贴到自己常用的 Email 程序中.

   有时候你面对的错误可能是由于 Emacs 或 Org-mode 配置错了. 在报告 BUG 之前,最后以最小客户化的形式启动 Emacs 然后复现这个 BUG. 这样做常常能够帮助你确定这个问题是因为配置的关系还是 Org-mode 本身有问题. 你可以用下面这个命令来开启一个最低客户化的 session
   #+BEGIN_SRC sh
     emacs -Q -l /path/to/minimal-org.el
   #+END_SRC
   
   如果你使用的是 Emacs 中自带的 Org mode,那么上面哪个最小客户化的配置就没有必要了. 你可以直接用'emacs -Q'来打开 Emacs. 一个典型的'minimal-org.el'配置文件可能包含如下内容
   #+BEGIN_SRC emacs-lisp
     ;;; Minimal setup to load latest `org-mode'
     
     ;; activate debugging
     (setq debug-on-error t
           debug-on-signal nil
           debug-on-quit nil)
     
     ;; add latest org-mode to load path
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/lisp"))
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/contrib/lisp"))
     
     ;; activate org
     (require 'org-install)
   #+END_SRC
   如果有错误发生,一个错误的跟踪栈对查找问题很有帮助(下面说明了如何创建一个跟踪栈). 通常提供一个简单的造成错误的简单例子会很有帮助, 再加上以下这些信息:
   #+BEGIN_EXAMPLE
     1. 你做了什么
     2. 你希望的结果是什么
     3. 实际上的结果是什么
   #+END_EXAMPLE
   
   感谢您帮助我们改进这个程序.
*** 如何创建一个有用的跟踪栈
    如果 Org 报出了一个 i 额你不明白的出错信息,你可能发现了 BUG. 报告这个 BUG 的最好方法是提供一个跟踪栈(backtrace). 跟踪栈使用内置的调试信息来收集一些信息,这些信息包括错误发生的地点和方式. 下面是提供一个有用跟踪栈的步骤
    1. 重新加载未编译的所有 Org mode 的 Lisp 源文件. 如果错误是在未编译的脚本中产生时,跟踪栈能够提供多得多的信息. 要做到这一步,执行
       #+BEGIN_EXAMPLE
         C-u M-x org-reload RET
       #+END_EXAMPLE
       或者在 Emacs 菜单上选择'Org -> Refresh/Reload -> Reload Org uncompiled'
    2. 在'Options'菜单中选择'Enter Debugger On error'(如果是使用 XEmacs,需要在'Troubleshooting'子菜单中选择此项).
    3. 复现错误,别忘了记录操作的每个步骤
    4. 当错误产生了,一个名为*Backtrace*的缓存区会显示出来,保存这个缓存区到文件中(一般是用 C-x C-w 命令)然后附加在你的错误报告中.
** 手册中的排版约定  : 手册中的排版约定
   Org 使用三种类型的关键字:TODO 关键字,标签和属性名称. 在该手册中我们使用如下约定:
   #+BEGIN_EXAMPLE
   TODO
   WAITING
   #+END_EXAMPLE
   TODO 关键字全部大些,即使它们可以用户随意定义的.
   
   #+BEGIN_EXAMPLE
   boss
   ARCHIVE
   #+END_EXAMPLE
   
   用户自定义的标签使用全小些;内置的标签具有特定的意义,使用全大些形式
   #+BEGIN_EXAMPLE
   Release
   PRIORITY
   #+END_EXAMPLE
   用户自定义的属性使用首字母大些;内置属性有特定意义的,使用全大些形式.
   
   该手册列出特定功能的键序列和相应的命令. Org mode 经常使用相同的键序列来在不同的上下文中触发不同的功能. 绑定到这些键序列的命令都有一个通用的名称,比如'org-metaright'. 在该手册中,我们会尽可能的给出通用命令内部调用的函数名称. 例如,在文件结构的章节上按下'M-<right>'会被指明调用的是'org-do-demote'程序,而在表标题上按下相同的键序列时,我们会指明调用的是'org-table-move-column-right'.

   如果你愿意,你可以编译这份手册使之不带有命令名称,方法是在'org.texi'中取出'cmdnames'标志.
* 文档结构
  Org 是基于 Outline-mode 的,它提供了大量的命令来编辑文档的结构.
** 大纲                  :Org 是基于 Outline-mode 的
   Org 的实现是基于 Outline-mode 的.Outline 运行文档按照分级结构的方式来组织,这种方式(至少对于我来说)是用来展示记录和想法的最佳方式.通过折叠(隐藏)绝大部分的文档内容而只显示文档的大致结构和正在编辑的这一部分内容,一个文档结构的总览被完美地展示出来. Org 极大地简化了对大纲的操作,它把整个显示/隐藏功能都通过一个命令来完成:'org-cycle',这个命令被绑定到了<TAB>键上.
** 标题                  :如何排版 Org 的树状标题
   标题定义了大纲树的结构. Org 的标题以一个或多个星号开头,向左对齐[fn:4]. 例如:
   #+BEGIN_SRC org
     ,* Top level headline
     ,** Second level
     ,*** 3rd level
     ,    some text
     ,*** 3rd level
     ,    more text
     
     ,* Another top level headline
   #+END_SRC

   有些人觉得太多的星号眼花缭乱,它们可能更喜欢 Outline-mode 使用空格加星号的格式作为标题的开始标识.[[A cleaner outline view][一个更简洁的大纲显示]]中描述了如何配置.

   在子树的末尾的空行,被认为是子树的一部分,它会随着子树的折叠而被隐藏. 然而,如果你放了两个空行,那么在折叠这个子树的时候,还会有一个空行是可见的,这样做的目的常常是为了构造分割的视图. 要改变这种行为,需要配置变量'org-cycle-separator-lines'
** 可见性的转换           :显示和隐藏,很简单
   Outline 使得隐藏缓存区中的一部分文本成为可能. Org 仅仅使用两个命令来切换缓存区的可见性,这两个命令被绑定到了'<TAB>'和'S-<TAB>'上.
   * <TAB> (org-cycle) :: 子树循环:以下面的循环状态来切换当前子树的状态
	#+BEGIN_EXAMPLE
	,-> FOLDED -> CHILDREN -> SUBTREE --.
	'-----------------------------------'
	#+END_EXAMPLE
	为了执行子树的切换,光标位置必须在子树的标题上[fn:5]. 若光标在缓存区的最前端,而这第一行又不是标题,那么<TAB>实际上执行的是'全局循环'(具体情况见下文)[fn:6]. 同样的,如果使用的是带前缀参数的<TAB>(C-u <TAB>),调用的也是'全局循环'
   * S-<TAB> / C-u <TAB> (org-global-cycle) :: 全局循环:使整个缓存区在在不同状态间切换
	#+BEGIN_EXAMPLE
	 ,-> OVERVIEW -> CONTENTS -> SHOW ALL --.
	'--------------------------------------'
	#+END_EXAMPLE
	若再 S-<TAB>前加了一个数字前缀 N,那么 CPMTEMTS 一直到第 N 个层次的内容都会显示出来. 需要注意的是,若是在编辑表格中,S-<TAB>的作用是跳到上一个域.
   * C-u C-u <TAB> (show-all) :: 
	显示所有信息,包括'抽屉'内的信息
   * C-c C-r (org-reveal) :: 
	显示光标周围的上下文,也就是显示当前条目,以及所有上层标题. Useful for working near a location that has been exposed by a sparse tree command (see section Sparse trees) or an agenda command (see section Commands in the agenda buffer). With a prefix argument show, on each level, all sibling headings. With a double prefix argument, also show the entire subtree of the parent. (TODO 真没看懂什么意思,在实验 C-c C-r 的时候我的 Org 居然没反应...)
   * C-c C-k (show-branches) :: 
	展开所有子树的标题,如果只有一个子树,那么内容也显示出来.
   * C-c C-x b (org-tree-to-indirect-buffer) :: 
	把当前子树显示在 indirect buffer 中[fn:7]. 如果加了一个前缀参数 N,它会向下进入地 N 层子树并在 indirect buffer 中显示该子树. 如果 N 是负数,那么就是向上进入 N 层的父节点. 如果命令执行前加了 C-u 前缀,则打开新的 indirect buffer,而不会关闭之前打开的 indirect buffer.
   * C-c C-x v (org-copy-visible) :: 
	拷贝文本块中的可见文本到 kill ring 中
	
   当 Emacs 第一次打开一个 Org 文件时,全局状态为 OVERVIEW,也就是说,只有顶层的标题是可见的. 这个行为可以通过配置'org-startup-folded'变量来改变.或者可以在文件的任何地方添加下面所列出的任何一句,Emacs 就会根据这句配置信息自动设置初始的状态.
   #+BEGIN_SRC org
     ,#+STARTUP: overview
     ,#+STARTUP: content
     ,#+STARTUP: showall
     ,#+STARTUP: showeverything
   #+END_SRC

   此外,任何带有'VISIBILITY'属性名的条目(参考[[#Properities and columns][属性与列]])会相应地按照该属性值来设置可见性. 该属性的有效值可以使'folded','children','cotent'和'all'
   * C-u C-u <TAB> (org-set-startup-visiblity) ::
     重置该 buffer 的可见性为该 buffer 在启动时的可见性,也就是说根据 buffer 的'startup'选项和各个单独条目的'VISIBILITY'属性来重新设置整个 buffer 的可见性.
** 移动                  :跳转到其他标题
   下面的命令跳转到 buffer 中的其他标题
   * C-c C-n (outline-next-visible-heading) ::
     下一个标题
   * C-c C-p (outline-previous-visible-heading) :: 
	上一个标题
   * C-c C-f (org-forward-same-level) :: 
	同一级的下一个标题
   * C-c C-b (org-backward-same-level) :: 
	同一级的上一个标题
   * C-c C-u (outline-up-heading) :: 
	回到上一级标题
   * C-c C-j (org-goto) :: 
	跳转到其他位置的同时不改变当前大纲的可见性. 在一个临时 buffer 中显示文档的结构,在这个临时 buffer 中你可以使用下面的快捷键来定位:
	#+BEGIN_EXAMPLE
	<TAB>           切换可见性
	<down> / <up>   下一个/上一个可见的标题
	<RET>           选定当前位置
	/               在树中作一个匹配查询
	如果你关掉了 org-goto-auto-isearch 选项,下面这些快捷键才可用
	n / p           下一个/上一个可见的标题
	f / b           同级别的上一个/下一个标题
	u               回到上一级标题
	0-9             数字参数
	q               退出这个临时 buffer
	#+END_EXAMPLE
	参见变量'org-goto-interface'
** 结构编辑               :改变标题的次序和层次
   * M-<RET> (org-insert-heading) ::
     插入一个与当前位置同级别的新标题. 如果光标位于一个普通的列表项,新的列表项被创建(参见[[#Plain list][普通列表]]). 要强制创建新标题,则需要使用前缀参数. 如果在一行的中间执行这个命令,那么这一行会被分割成两行,光标到行尾的内容会成为新的标题[fn:8]. 如果实在一个标题的开头执行这个命令,那么新标题会天骄到当前行的前面. 如果是在所有行的前面执行这个命令,那么就创建了一个新的文件头. 如果是在折叠起来的子树末尾使用这个命令(也就是说,是在标题末尾的省略号之后),那么与当前标题类似的标题会被插入到这个子树的末尾.
   * C-<RET> (org-insert-heading-respect-content) :: 
	类似与 M-<RET>,不同之处在于,当在当前标题后增加一个新标题时,M-<RET>会在当前标题的内容前增加一个新标题(内容成为这个新标题的内容),而 C-<ERT>则在内容后增加一个新标题(内容还是原标题的内容). 这个命令在条目的任何地方都是一样的行为.
   * M-S-<RET> (org-insert-todo-heading) :: 
	插入一个与当前标题同级别的 TODO 事项. 参见变量'org-treat-insert-todo-heading-as-state-change'
   * C-S-<RET> (org-insert-todo-heading-respect-content) :: 
	插入一个与当前标题同级别的 TODO 事项, 与 C-<RET>类似,新的标题会插在当前子树的后面.
   * <TAB> (org-cycle) :: 
	在一个未输入内容的标题上,第一次按<TAB>,这个标题成为了上一个标题的子标题,再按一下<TAB>,这个标题的级别变成了上一个标题的父标题,然后每按一次<TAB>级别就上升一级,一直到最高级.到了最高级再按一次<TAB>,又会回到初始的级别.
   * M-<left> (org-do-promote) :: 
	提升当前标题一级
   * M-<right> (org-do-demote) :: 
	降低当前标题一级
   * M-S-<left> (org-promote-subtree) :: 
	提升当前子树一级
   * M-S-<right> (org-demote-subtree) :: 
	降低当前子树一级
   * M-S-<down> (org-move-subtree-up) ::
        上移当前子树(与同级别的上一个子树交换位置)
   * M-S-<down> (org-move-subtree-down) ::
        下移当前子树(与同级别的下一个子树交换位置)
   * C-c C-x C-w (org-cut-subtree) :: 
	剪切当前子树,也就是说把当前子树从 buffer 移到 kill ring 中. 加一个前缀参数 N,会剪切 N 个连续的子树.
   * C-c C-x M-w (org-copy-subtree) :: 
	把当前子树拷贝入 kill ring 中, 加上一个前缀参数 N,会拷贝 N 个连续子树
   * C-c C-x C-y (org-paste-subtree) :: 
	从 kill ring 中粘贴子树. 该操作会自动更改被粘贴子树的级别以便它能够使用粘贴的位置. 你也可用在粘贴时就指定好级别,方法有两个,一个是在粘贴命令前加一个数字前置参数,第二种方法是在已经标示好的标题(比如'****')后粘贴子树.
   * C-y (org-yank) :: 
	根据变量'org-yank-adjusted-subtrees'和'org-yank-folded-subtrees'的值,org-yank 可用很智能地用与命令 C-c C-x C-y 一样的方式来粘贴折叠起来的子树. 在缺省的配置中,org-yank 不会调整级别,并且除非会把原先可见的文本折叠起来,否则被粘贴的子树会子的那个被折叠起来. 任何前缀参数会让这个命令强制执行一个带着前缀参数的普通的 yank 操作. 要强制执行普通 yank 的一个好方法是按下 C-u C-y. 如果在 yank 之后,你紧接着执行 yank-pop 命令,就会 yank 当前 kill-ring 前一个的内容,而且不会作调整和折叠动作.
   * C-c C-x c (org-clone-subtree-with-time-shift) :: 
	拷贝一堆的同级副本. 你可以一次性拷贝多个同级副本,并且你若拷贝的条目中含有时间戳信息的化,你还可以定义时间戳信息如何变化. 这项功能十分有用,例如,当你要分配任务来准备一系列的课程时. 更多细节参见命令'org-clone-subtree-with-time-shift'的文档字符串.
   * C-c C-w (org-refile) :: 
	转存指定条目或文本块到另一个地方.参见章节[[#Refiling note][转存记录]].
   * C-c ^ (org-sort-entries-or-items) :: 
	对同级条目进行排序. 如果选择了一块文本块,所有文本块中的条目都会被排序. 否则当前标题下的子节点进行排序. 该命令会提示你选择排序的方法,可选择的方法有按字母顺序排序,按数字顺序排序,按时间排序(创建时间,规划时间,最后期限),按优先级排序,按 TODO 的关键字排序(需预先在配置中定义好关键字的排序顺序),按属性值排序. 你也可以采取逆排序的方式排序. 你甚至可以提供自己的函数来对其他的关键字进行排序. 如果加了 C-u 前缀,排序是大小写敏感的.
   * C-x n s (org-narrow-to-subtree) :: 
	缩减 buffer 只显示当前的子树的内容
   * C-x n s (org-narrow-to-block) ::
        缩减 buffer 只显示当前块的内容
   * C-x n w (widen) :: 
	回复被缩减的 buffer
   * C-c * (org-toggle-heading) :: 
	该命令把正文转变为一个标题(正文在它的位置成为上一个标题的一个子标题). 也会把一个标题转变为正文. 如果选择了一个文本块,那么文本块中的所有行都变成标题. 如果该文本块中第一行是一个 item(什么意思??),那么只把这个 item 转换为标题. 最后,如果文本块中第一行是一个 i 额标题,那么该文本块中所有的标题都变成正文.

   当对一个选定的文本块(Transient Mark mode)作升级/降级操作时,会影响到文本块中所有的标题.  要选择一个包含很多标题的文本块,最好是把 point 和 mark 都放在行首,mark 放在第一个标题的行首,point 放在要改变的最后哪个标题的下一行的行首. 需要注意的是,如果光标在表格内部(参见[[#tables][表格]]). Meta-光标键的操作有不同的作用.
        
** Sparse 树              :与情景有关的匹配
   Org-mode 的一个很重要的功能是它可以根据一系列的条件,将一棵大纲树中所匹配出来的一部分形成一棵 sparse 树,也就是说,整个文档都会尽可能的折叠起来,唯独所匹配的信息和上级标题是可见的[fn:9]. 你只要尝试以下,就立刻能够明白它是怎么工作的. 

   Org-mode 有很多命令可以创建 Sparse 树,所有这些命令都可以通过 dispatcher 来触发.

   * C-c / (org-sparse-tree) ::
        它会提示你输入一个额外的快捷键来选择特定的 sparse 树的创建命令
   * C-r / r (org-occur) :: 
	提示输入一个正则表达式,然后显示所有匹配的 sparse 树. 如果有标题匹配,那么只有这个标题可见. 如果是正文匹配,那么标题和正文同时可见. 为了提供最低限度的上下文信息,所有上层标题和紧跟者匹配部分的标题都会被显示. 每个匹配的部分都被高亮; 若这是你对文档进行编辑动作,则高亮会消失[fn:10]. 同样你也可以通过 C-c C-c 来取消高亮. 如果执行 C-u C-c / r 则以前匹配的高亮会被高持,这样多次调用这个命令的结果就被保存了下来.
   * M-g n 或者 M-g M-n (next-error) :: 
	跳到当前 buffer 中匹配的下一个 sparse 树
   * M-g p 或者 M-g M-p (previous-error) :: 
	跳到当前 buffer 中匹配的上一个 sparse 树

   对于那些常用的 sparse 树查询,你可以在变量'org-agenda-custom-commands'中定义快捷键,直接执行这些 sparse 树查询. 然后就可以在 agenda dispatcher 中使用这些快捷键来快速查询了.例如
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-custom-commands
           '(("f" occur-tree "FIXME")))
   #+END_SRC
   会定义一个键序列为'C-c a f'的快捷方式,这个快捷方式会通过匹配字符串'FIXME'来创建 sparse 树.

   其他的 sparse 树命令(例如通过 TODO 关键字,标签或者属性来查找)会在手册后一点的位置提到.

   要打印出 sparse 树,你可以使用 emacs 命令'ps-print-buffer-with-faces',这个命令不会把不可见部分给打印出来[fn:11]. 或者你可以用命令'C-c C-e v'把可视化的部分导出到文档中,然后打印导出文档.
** 纯文本列表             :条目中的附加结构
   在大纲树的正文内容中,手工排列好的列表被认为是带有一定结构的. Org 提供了一种方式来创建带复选框的列表(参见[[#Checkboxes][复选框]]),它提供工具来编辑这种列表,并且在导出时(参见章节[[Exporting][导出]])能够解析并且格式化这些列表.

   Org 支持有序列表,无序列表和描述列表
   * 无序列表,以'-','+'或者'*'[fn:12]开头
   * 有序列表以数字开头,后接句号或者右括[fn:13](像这样'1.','1)')[fn:14]. 如果你想让列表以其他值作为初始值开始计数,需要以类似[@20]这样的文本开头[fn:15]. 这样的用法可以用在列表的任何一项上(而不需要仅仅是第一项),以强制从指定数字顺序开始.
   * 描述列表是一种无序列表,它包含'::'作为分隔符来分割术语和描述.
     
   同一个列表中的列表项必须有相同的缩进. 尤其当一个有序列表的计数达到了'10'的时候,那么这两位的计数必须与列表中的其他计数左对齐. (一个列表项可以是多行的.)当一个列表项的下一行的缩进与该列表项本身的缩进相等甚至跟少时,才表示该列表项结束了.

   当所有的列表项结束时,一个列表才被认为是结束了的,这意味在有一行的缩进等于或者小于列表第一项的缩进前,该列表都没有结束. 当然,你也可以用两个空白行[fn:16]来强制结束列表. 这种情况下,所有的列表项都被关闭了.下面是一个例子.
   #+BEGIN_SRC emacs-lisp
     ,** Lord of the Rings
        My favorite scenes are (in this order)
        1. The attack of the Rohirrim
        2. Eowyn's fight with the witch king
           + this was already my favorite scene in the book
           + I really like Miranda Otto.
        3. Peter Jackson being shot by Legolas
           - on DVD only
           He makes a really funny face when it happens.
        But in the end, no individual scenes matter but the film as a whole.
        Important actors in this film are:
        - Elijah Wood :: He plays Frodo
        - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
          him very well from his role as Mikey Walsh in The Goonies.   
   #+END_SRC

   Org 能正确地对这些列表进行 filling 和 warpping 调整[fn:17], 而且能够以一种恰当的方式导出这些列表(参见[[#Exporting][导出]]). 由于缩进决定了这些列表的结构,许多像#+BEGIN_...这样的 block 可以通过缩进来表明它们是属于哪一个列表项的一部分的.

   如果你觉得为子列表使用不同的标示(而不使用当前列表项的标示)可以增加可读性,你可以自定义变量'org-list-demote-modify-bullet'. 如果你想改变缩进程度,自定义变量'org-list-indent-offset'

   当光标处于某列表项的第一行(即带有列表项标示的那一行),可以用下面这些命令来对列表项进行操作. 其中有些命令暗含某些规则来保证列表结构是正确的. 如果你想让这些命令妨碍了你,可以通过配置'org-list-automatic-rule'来禁用其中的某些命令.
   * <TAB> (org-cycle) ::
        列表项可以像标题一样具有折叠的功能. 正常情况下,只有当光标处在 plain list item 上时才能进行这种折叠操作. 欲了解更多的细节,请看变量'org-cycle-include-plain-lists'. 如果该变量的值为'integrate'. plain list items 会被当成是低层次的标题看待. 而*号和数字缩进层次则决定了把它当成几级标题来看待. 列表项的等级总是要低于真正的标题, 然而列表的等级制度与标题的等级制度是完全分开的. 在一个新的还未写内容的列表项上,第一次按<TAB>会把它变成上一个列表项的子项.再按一次<TAB>会上升一个层级,并且下去直到最顶列表项的层级,再按一次则返回最原始的层级位置.
   * M-<RET> (org-insert-heading) :: 
	插入新列表项到当前层级. 若在前面加了前缀参数,则强制插入的是标题(参见[[#Structure editiong][结构编辑]]). 如果在一个列表项的中间位置执行这条命令,这个列表项会被分为 2 部分,而第二部分则变成了一个新的列表项[fn:18]. 如果在列表项的内容前执行这个命令,则新列表项插入在当前列表项前.
   * M-S-RET :: 
	插入带复选框的列表项(见[[#Checkboxes][复选框]])
   * S-up 和 S-down :: 
	跳转到当前列表的上一个/下一个列表项上去[fn:19],不过该命令只有在'org-support-shift-select'被关闭的情况下才能用. 如果不是的话,你可以使用段落跳转命令代替,快捷键为 C-<up>和 C-<down>
   * M-up 或 M-down :: 
	向上或者向下移动列表项及其子项[fn:20](与上一个/下一个同缩进的列表项交换). 如果列表是有序列表,会自动重新计算序号.
   * M-S-left 和 M-S-right ::
        减少/增加列表项(联通其子项)的缩进. 在第一次开始改变缩进时 Org 就会记住缩进的范围,并且在以后的多次缩进中都以次范围为准进行缩进,即使在缩进过程中可能会形成新的继承体系也不管. 如果你想在新的继承体系上进行缩进,那么你可以移动以下光标或者其他方法来先中端命令链,重新开始新的缩进过程.

        作为一种特殊的情况,在列表的第一个列表项上用这个命令会移动整个列表. 你可以通过配置'org-list-automatic-rules'来禁止这种行为. 一个列表的总体缩进对列表后面的文本并无影响力(什么意思??)
   * C-c C-c :: 
	如果所在的列表项是带复选框的(参见[[#Checkboxes][复选框]]),那么就会转换复选框的状态. 在任何情况下,该命令都会校验整个列表序号和缩进的一致性.
   * C-c - :: 
        循环更改整个列表的列表项标志(对于无需列表:'-','+','*';对于有序列表:'1.','1)'),更改的具体方式依据'org-plain-list-ordered-item-terminator',列表的类型和列表项的位置来决定的[fn:21]. 如果加了一个数字前缀 N,就会选择'+,*,1.,1),-'中第 N 个标识作为列表项的标识. 如果在调用该命令时选择了一个文本块,那么整个文本块会转换成一个列表项. 如果加了前缀参数,那么文本块中所有的行各自转换成为列表项. 如果第一行依据是一个列表项,那么文本块中所有的列表项标识都被删除. 最后,即使没有选择文本块,一个普通的文本行也会转换成列表项.
   * C-c * :: 
	把一个普通列表转换为标题(这样它就原地转换为了一个子标题). 更详细的扩展参见[[#Structure editing][结构编辑]].

   * C-c C-c * :: 
	把整个列表转换成当前标题下的子树. 带复选框的列表项(参见[[#Checkboxes][复选框]])会转换成 TODO(复选框没被选上)或者 DONE(复选框被选上)关键字.
   * S-left 或 S-right :: 
	当光标处于列表项的任意位置上时,这个命令也会起到循环转换列表项标志的作用. 具体怎么转换依赖于'org-support-shift-select'
   * C-c ^ :: 
	对列表进行排序. 你会被提示输入排序方法,有按数字排序,按字符排序,按时间排序或自定义方法排序.
** 抽屉                  :收缩起所有的资料
   有时候你想记录下一项事务的某些信息,但是这些信息在一般情况下是没必要显示出来的. 为了实现这个目的,Org mode 提供了 drawers 功能. drawers 需要在变量'org-drawers'[fn:22]中进行配置. Drawers 看起来就像这样:
   #+BEGIN_SRC org
     ,** This is a headline
     ,   Still outside the drawer
     ,   :DRAWERNAME:
     ,   This is inside the drawer.
     ,   :END:
     ,   After the drawer.
   #+END_SRC

   无论如何在标题上切换可见性(参见[[#Visibility cycling][切换可见性]]),drawer 都是收缩为一行显示的. 要看 drawer 内的信息,你需要移动鼠标到 drawer 这一行,然后按<TAB>键. Org-mode 使用名为'PROPERTIES'的 drawer 来存放属性(参见[[#Properties and columns][属性与列]]), 你也可以把状态改变记录(参见[[Tracking TODO state changes][跟踪 TODO 状态变化]])和计时时间(参见[[#Clocking work time][记录工作时间]])存放在名为'LOGBOOK'的 drawer 中. 如果你想像状态变化信息一样把自己的一段记录也存放到名为'LOGBOOK'的这个 drawer 中,使用
   * C-c C-z ::
        添加一个带有时间戳信息的记录到名为'LOGBOOK'的 drawer 中
** 区块                  :折叠的区块
   Org-mode 使用 begin...end 块来实现很多功能,比如引入源代码(参见[[#Literal examples][文学化例子]]),记录计时信息(参见[[#Clocking work time][记录工作时间]]). 在这些区块的第一行上按 TAB 键可以折叠/扩展该区块. 你也可以在设置在启动时自动折叠所有的块,方法是配置变量'org-hide-block-startup'或者在每个文件加上
   #+BEGIN_SRC org
     ,#+STARTUP: hideblocks
     ,#+STARTUP: nohideblocks
   #+END_SRC
** 注脚                  :如何用 Org 标签定义注脚
   Org-mode 支持创建注脚. 与'footnote.el'包相反,Org-mode 中的注脚功能是专门设计在大型文档来使用的,而不仅仅是用在类型 email 这样的一次性文件上的. org-mode 中注脚的基本语法类似于'footnote.el'中的语法,即,要在段落中定义一个注脚,它需要顶格(不能有缩进)以方括号作为注脚的标记. 如果你需要在注脚内分段,使用 LaTeX 语法'\par'. 要定义注脚引用,只需要简单的在文本中用方括号做一个标记. 例如
   #+BEGIN_SRC org
     ,The Org homepage[fn:1] now looks a lot better than it used to.
     ,...
     ,[fn:1] The link is: http://orgmode.org
   #+END_SRC
   
   Org-mode 会把'footnote.el'中基于数字的语法扩展为可以为注脚命名并且可以选择给注脚提供内部定义. 使用纯数字作为注脚标注(footnote.el 就是这样作的)是为了提供向后兼容性,但是这种方式不鼓励使用,因为这种方式可能会与 LaTeX snippets(参见[[#Embedded LaTeX][内嵌 LaTeX]])冲突. 下面列举几种有效的注脚引用:
   * [ 1 ] ::
        一个纯数字的注脚标记. 与'footnote.el'兼容,但是不推荐使用,因为像'[ 1 ]'这样的东西,很可能是 code snippet 的一部分.
   * [ fn:name ] :: 
	一个带有名字的注脚引用,这里 name 是一个唯一的标签.如果是自动创建的注脚引用的化,则会是一个数字.
   * [ fn:: This is the inline definitiion of this footnote ] :: 
	这是一个类似 LaTeX 的匿名注脚,其中注脚的定义直接放在引用的位置.
   * [ fn:name:a definition ] ::
        这是一个带有名字的自定义的注脚. 由于 Org-mode 允许从多处引用到同一个说明,你可以使用[ fn:name ]来创建更多的引用.

   注脚标记可以被自动创建,你也可以自定义标记自动创建时的名字. 这是由变量'org-footnote-auto-label'变量和变量相应的'#+STARTUP'关键字来决定的. 欲了解详情请查看该变量的文档字符串.

   下面这些都是操作注脚的命令
   * C-c C-x f ::
     注脚行为命令

     当光标位于注脚引用处,该命令会跳转到注脚定义处. 若光标处于注脚定义处,跳转到(第一个)引用处.

     否则,创建一个新的注脚. 根据变量'org-footnote-define-inline[fn:23]'的不同,该注脚的定义可能是作为引用的一部分,会放在文本中, 也可能放在另外的其他位置,这个位置由变量'org-footnote-section'决定.

     当使用带前置参数的方式调用该命令, 会显示出一个附加选项菜单供你选择:
     #+BEGIN_EXAMPLE
       s   以引用顺序为依据对注脚的定义进行排序. 在编辑过程中,Org 不会对注脚的定义进行排序操作. 如果你向对这些注脚的定义进行排序,使用这个命令,在对注脚定义进行排序的同时,也会根据'org-footnote-section'来移动整个条目. 用户可以通过配置变量'org-footnote-auto-adjust'来实现在每次插入/删除一个注脚后自动对注脚定义进行重新排序.
       r   对类型 fn:N 这样的以简单数字命名的注脚进行重新编号. 可以通过配置变量'org-footnote-auto-adjust'来实现每次插入/删除一个标注就自动对标注进行重新编号.
       S   先执行 r 操作,然后执行 s 操作
       n   标准化所有的标准,方法为先收集所有的标注定义(包括自定义的标注定义)并移动到一个特定的区域中,然后按顺序对这些定义进行编号. 那些标注引用随后也会转换为相应的数字. 这常常是在完成一篇文档前的最后一个步骤(例如,要发送 email 时). 在导出文档时,exporter 会自动作这一步.或者当触发类似 message-send-hook 时,类似的动作也会自动触发.
       d   删除当前位置的标注,连同所有的标注定义和标注引用
     #+END_EXAMPLE

     根据变量'org-footnote-auto-adjust[fn:24]'的值,可以设定每插入或删除一个注脚后,自动重编码和排序文档中的所有注脚.

   * C-c C-c :: 
	当光标位于注脚引用处时,跳转到注脚定义处. 若光标处于注脚定义处,则跳转回注脚引用处. 若在标注位置上用带前置参数的方式调用该命令,则弹出一个与 C-c C-x f 一样的菜单.

   * C-c C-o 或 鼠标左键 或鼠标右键 :: 
	注脚标签也是注脚定义与注脚引用相互之间的一种链接,你可以使用跳转链接的一般命令来在注脚定义/引用间相互跳转.
** Orgstruct 的 minior 模式 :在 Org 之外进行结构编辑
   如果你喜欢 Org-mode 编辑结构和格式化列表时的这种直接了当的感受,你可能希望在其他 mode 下(比如 Text-mode 或者 mail-mode)也能使用这些命令. 这时你可以使用名为'orgstruct-mode'的 minor mode. 使用'M-x orgstruct-mode'来切换 mode. 如果你想在默认情况下启用'orgstruct-mode',例如设置在 Message-mode 下默认启用该 mode,可以在配置文件中添加下面中的任一句
   #+BEGIN_SRC emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgstruct)
     (add-hook 'message-mode-hook 'turn-on-orgstruct++)
   #+END_SRC

   'orgstruct-mode'被激活后,当光标在一行(对 org 来说)看起来像是标题或列表项的第一行的文本行上时,大多数的结构编辑命令都可以被使用,即使在 major mode 原本定义的功能键跟'orgstruct-mode'提供的功能键有冲突时,也一样. 如果光标所在行看起来不是那种特殊的行,Orgstruct mode 不会有任何作用,就跟没有开启 Orgstruct mode 一样. 若你使用的是'orgstruct++-mode',Org 也会在 major mode 中引入缩进和填充设置,并且会探测列表项第一行后面的列表项内容.
* 表格
  Org 自带一个快速而且直观的表格编辑器. 借助 Emacs 的'calc'包(参见<Gnu Emacs calculator manual>中的'Top'部分)甚至可以具备类似电子表格的计算能力.
** 内置的表格编辑器        :编辑简单的表格
   Org 可以很容易的使用纯文本来格式化表格. 任何以'|'为非空白字符开头的行都被认为是表格的一部分. '|'也是列的分隔符[fn:25].一个表格看起来类似于这样:
   #+BEGIN_SRC org
     ,| Name  | Phone | Age |
     ,|-------+-------+-----|
     ,| Peter |  1234 |  17 |
     ,| Anna  |  4321 |  25 |     
   #+END_SRC
   
   每次在表格内按<TAB>,<RET>或'C-c C-c'都会自动对表格进行重排. <TAB>也使光标移动到下一个域(<RET>使光标移动到下一行)并且会在表格的最后一行或者在水平线之前的位置上添加一行新行.表格的缩进是由第一行来决定的. 任何以'|-'开头的行都被认为是水平分割行,并且在下一次表格重排时会扩展到整个表格的长度. 所有要创建上面的表格,你只需要键入
   #+BEGIN_SRC org
     ,|Name|Phone|Age|
     ,|-    
   #+END_SRC
   然后按下<TAB>来对齐表格并且开始在表格域内进行填充操作. 更快的操作是输入"|Name|Phone|Age"然后紧接着输入'C-c <RET>'.

   当在表格域内输入文本时,Org 以一种特殊的方法来处理<DEL>,<Backspace>,和所有的字符键,这种方法保证了插入和删除操作可以避免对其他域产生影响. 另外,如果是在光标通过<TAB>,S-<TAB>或<RET>的方式移动到新表格域后立即输入,那么新表格域中的文本会被自动清空. 如果这种行为对你产生了困扰,可以配置变量'org-enable-table-editor'和'org-table-auto-blank-field'来取消这种行为.

   * 创建和转换命令
     * C-c | (org-table-create-or-convert-from-region) ::
          转换选定域为表格. 如果每个行都包含了至少一个 TAB 键,那么该函数假设选定域的值是以 tab 键作为分隔符的. 如果每一行都包含了一个逗号,那么选中域被假设为是 CSV 文件内容. 如果即没有 TAB,也没有逗号,那么就认为选中域是以空格为分隔符的. 你可以使用前置参数来告诉函数使用哪种分隔符:C-u 使用 CSV 格式,C-u C-u 使用 TAB 为分隔符,前置参数 N 标示至少 N 个连续的空格或 TAB 键作为分隔符.

          如果没有选定域,这个命令会创建一个空的 Org 表格. 至少它比输入"|Name|Phone|Age<REt>|-<TAB>"这样来的简单.
   * 重对齐和表格域之间的移动
     * C-c C-c (org-table-align) ::
          对表格进行重对齐操作但不移动光标的位置
     * <TAB> (org-table-next-field) :: 
	  重对齐操作,光标移动到下一个域中. 如果需要的话创建一个新行.
     * S-<TAB> (org-table-previous-field) :: 
	  重对齐操作,光标移动到上一个域中.
     * <ERT> (org-table-next-row) :: 
	  重对齐表格,并且光标移到下一行. 如果需要的话会新键一行. 若光标在一行的开头或末尾,<ERT>也会新建一行,因此该功能可以用来分割表格.
     * M-a (org-table-beginning-of-field) :: 
	  移动到光标当前域的开头位置,或者(若已经在当前域的开头位置)上一个域的开头位置
     * M-e (org-table-end-of-field) :: 
	  移动到光标当前域的结尾位置,或者(若已经在当前域的结尾位置)下一个域的结尾位置
   * 列和行的编辑
     * M-<left> (org-table-move-column-left) ::
          移动当前列到左方(与左列交换位置)
     * M-<right> (org-table-move-column-right) ::
          移动当前列到右方(与右列交换位置)
     * M-<up> (org-table-move-row-up) :: 
	  移动当前行到上方(与上行交换位置)
     * M-<down> (org-table-move-row-down) :: 
	  移动当前行到下方(与下行交换位置)
     * M-S-<up> (org-table-kill-row) :: 
	  删除当前行或水平分隔行
     * M-S-<down> (org-table-insert-row) :: 
	  在当前行上面插入一新行. 如果加上前置参数,就在当前行下方插入新行.
     * C-c - (org-table-insert-hline) :: 
	  在当前行下面插入一新水平分隔行. 如果加上前置参数,就在当前行上方插入新水平分隔行.
     * C-c <RET> (org-table-hline-and-move) :: 
	  在当前行下方插入一水平分隔行,并且移动光标到该分隔行的下一行
     * C-c ^ (org-table-sort-lines) :: 
	  对当前块的表格行进行重新排序. 光标的位置指明根据哪一列来排序, 排序的范围就是上下两个最近的水平分隔行之间所包含的行,或者是整个表格. 如果光标处于第一列的前面,你会被提示需要输入按照哪一列来进行排序. 如果存在一个被选定的块,那么文本块的标记位置就指定了要排序的起始行,并且根据标记所在的列来进行排序,而光标所在的列(包括该列)为要排序的结束行. 该命令会提示您输入排序的类型(按字母排序,按数字排序或这按时间排序). 当该命令带有前置参数的时候,按字母排序是大小写敏感的.
   * 区域
     * C-c C-x M-w (org-table-copy-region) ::
          从表格中拷贝一个矩形区域到粘贴板. 光标所在的位置和标记的位置决定了矩阵的边界. 如果没有选定的区域,就把整个当前域拷贝到粘贴板中. 该操作会忽略水平分隔行.

     * C-c C-x C-w (org-table-cut-region) :: 
	  拷贝表格中的矩形区域的内容到剪贴板,并且对该矩形其余进行填空操作.因此这其实是个剪切操作

     * C-c C-x C-y (org-table-paste-rectangle) :: 
	  粘贴矩形区域内容到表格中. 该区域的左上角放置在当前域. 所有涉及到的域都会被覆盖掉. 如果矩阵不能合适地放到当前表格中,那么当前表会根据需要扩大. 该操作会忽略水平分隔行的存在.

     * M-<RET> (org-table-wrap-region) :: 
	  以光标位置为界限分割当前域,并且把剩下的部分移动到下一行. 如果存在已选定的文本块,并且光标和标记处于同一个列中,the text in the column is wrapped to minimum width for the given number of lines. 如果存在一个数字的前置参数,那么该参数会用来指定操作的行数. 如果没有选定的区域,而你又指定了前置参数,当前域会被清空,并且原先的内容会粘贴在当前域的上个域的内容后面.
   * 计算
     * C-c + (org-table-sum) ::
          把当前列(或选定区域)的数字求总和.求和的结果会在 echo 区域显示,并且可以用 C-y 命令插入结果

     * S-<RET> (org-table-copy-down) ::
          若当前域是空的,就会拷贝上方的第一个非空域的值. 如果当前域不是空的,则拷贝当前域的值覆盖下一行的值,并且鼠标也跟着下移. 根据变量'org-table-copy-increment'的设置,若域中的值是整数,则拷贝时会自增. 若域中的整数值太过巨大了,则该值不会被增加. 另外,若前置参数为 0,则会暂时地禁止这种增加行为. 该键序列在 shift-selection 和相关模式中也有定义,因此可能会有冲突(参见[[#Packages that lead to conflicts with org mode][与 org-mode 冲突的包]])
   * 杂项
     * C-c ` (org-table-edit-field) ::
          在另一个窗口中编辑当前域. 这在编辑显示不下内容的域时非常有用(参见[[#Column width and alignment][列宽度与对齐]]). 当添加了 C-u 前缀时,仅仅只是把当前域的内容全部显示出来,这样就能在本地编辑该域了. 如果加了两个 C-u 前缀则会保持一个编辑窗口,该窗口的内容随着光标的所在域不同而动态改变. 这种模式会一直持续到光标离开表格,或者你重复输入该命令'C-u C-u C-c `'

     * M-x org-table-import :: 
	  把一个文件当作表格导入进来. 文件内容必须是以 TAB 或空格分隔的(通常从电子表格或数据库中导出的数据是可以定义为以 TAB 分隔的文本文件的). 该命令先插入文件内容到缓冲区内然后调用转换命令(org-table-create-or-convert-from-region)将内容为一个表格. 任何前缀参数都会被传递给转换命令作为决定分隔符的参数.

     * C-c | (org-table-create-or-convert-from-region) :: 
	  也可以通过粘贴以 tab 分隔的文本到 Org 缓冲区的方式来导入表格.方法是,先用 C-x C-x 选择(也可以用其他方法)要粘贴的文本,然后使用'C-c |'命令

     * M-x org-tableexport :: 
	  导出表格,默认是以 TAB 作为分隔符. 常常用来与电子表格或数据库程序作数据交换. 导出文件的格式可以在变量'org-table-export-default-format'中配置. 你也可以在子树中用属性'TABLE_EXPORT_FILE'来定义导出文件的名字和属性'TABLE_EXPORt_FORMAT'来定义导出文件的格式. Org 支持将表格导出为许多格式. 导出的格式与 Orgtbl radio 表格的格式是一样的. 详细描述请参见'[[#Translator functions][转换功能]]'.

     如果你不喜欢 Org 的表格功能(因为你可能象要有记录一些以|开头的行,而不作为表格),你可以用下面的配置语句关掉该功能
     #+BEGIN_SRC emacs-lisp
       (setq org-enable-table-editor nil)
     #+END_SRC
     这样一来,唯一可用的表格命令就是 C-c C-c,该命令用来作人工的重对齐

** 列的宽度与对齐          :不使用自动化的设置
   列的宽度是有表格编辑器自动决定的. 列的对齐方式也是由列中的值的类型来自动决定的,若值类似于数字则默认右对齐,否则默认为左对齐.

   有时候,一个或多个域会由于包含了太多的文本而导致列的宽度看起来很不方便. 又或者你想象让多个列不管内容多少都保持固定的宽度. 要设置[fn:26]列的宽度, 在列的任何一个域中包含类似'<N>'这样的字符串即可. 这里 N 的意思代表了该列的宽度限定为 N 个字符长度. 下一次重排时,该列的宽度会调整为这个值.例如
   #+begin_example
     |---+------------------------------|               |---+--------|
     |   |                              |               |   | <6>    |
     | 1 | one                          |               | 1 | one    |
     | 2 | two                          |     ----\     | 2 | two    |
     | 3 | This is a long chunk of text |     ----/     | 3 | This=> |
     | 4 | four                         |               | 4 | four   |
     |---+------------------------------|               |---+--------|
   #+end_example

   太长的域会被裁减并且以字符串'=>'结尾. 注意,此时完成的字符串还保留在缓冲区内,只不过被隐藏起来罢了. 要查看完整的文本,只需要把鼠标移到要查看的域上过一会儿,会有一个小提示窗口弹出来,里面有完整的内容. 要编辑这个域,使用命令 C-c `(C-c 接着反引号). 该编辑命令会打开一个新窗口给你编辑,里面是完整的内容.输入 C-c C-c 完成编辑

   打开一个文件时,若文件中存在缩小的列的表格,此时列中的文本不会自动进行隐藏动作.这时候的表格看起来不太好看,需要重排. 设置选项'org-startup-align-all-tables'会使 org 在打开文件时自动重排其中的所有表格,当然这个动作也会降低 org 启动的速度. 你也可以在每个文件中设置这个属性,方法为:
   #+begin_src org
     ,#+STARTUP: align
     ,#+STARTUP: noalign
   #+end_src

   默认清空下富含数字的列是右对齐的,富含字符串的列是左对齐的,但你也可以自定义列的对齐方式,方法为在列中使用类似'<r>','c'[fn:27],或'<l>'这样的字符串来定义该列的对齐方式. 当然你也可以同时定义列对齐方式和列的宽度,例如'<r10>'.

   当导出文档时,只包含指定格式的字符串的行会自动移除不被导出.
** 对列进行分组            :Grouping to trigger vertical lines
   当 Org 导出表格时,默认是不导出表格中的竖线的,因为通常来说这不美观. 然而有时候竖线可用用来把表格划分为几个列的组(类似于水平分隔行把行划分为几个组别). 要定义列的组别,你可以使用一种特殊的行,在这一行里,第一个域只包含'/'. 接下来的域中可用包含'<'(表格这一列是一个组别的起始列),或者'>'(指示这一列是组别的结束列),或者'<>'('<'和'>'中间没有空格,这表示这一列自成一组). 组别之间的边界在导出时会用竖线标示出来.如下例子所示
   #+begin_src org
     ,| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|---+-----+-----+-----+---------+------------|
     ,| / |   < |     |   > |       < |          > |
     ,| 1 |   1 |   1 |   1 |       1 |          1 |
     ,| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
     ,| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
     ,|---+-----+-----+-----+---------+------------|
     ,#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))
   #+end_src
   
   你也可以只是在想要竖线的地方插入列组的起始符号即可.例如
   #+begin_src org
     ,|  N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|----+-----+-----+-----+---------+------------|
     ,| /  | <   |     |     | <       |            |
   #+end_src
** 名为 Orgtbl 的 minor mode :使用 minor-mode 中的表格编辑器
   如果你喜欢 Org 表格编辑器的直观操作，你也可以在别的 mode(例如 text-mode 或 mail-mode)中使用它. 名为'Orgtbl-mode'的 minor mode 可以实现这一点. 你可以通过'M-x orgtbl-mode'来切换该模式. 如果你想在进入特定 mode(例如 Message mode)时自动进入该 minor mode,使用如下的配置语句
   #+begin_src emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgtbl)
   #+end_src

   此外,通过一些配置,还可以用 Orgtbl-mode 实现在任意标签内包含表格. 例如,它可以实现在构建 LaTeX 表格时兼顾 LaTeX 的易用和 Orgtbl-mode 的能力(包含了电子表格的能力). 详细请见[[#Tables and lists in arbitrary syntax][任意标签中的表格和列表]]
** 电子表格               :带有电子表格功能的表格编辑器
   表格编辑器使用 Emacs 的'calc'包来实现类似电子表格的功能. 它也可以根据 Emacs Lisp 表达式来根据其他域中的值计算得出当前域的值. 虽然功能上类似,但是严格来说,Org 的实现方式与其他电子表格的实现方式是不一样的. 例如, Org 能够理解 column formula(列公式)的概念，列公式会自动应用到当前列的每一个非最开头的域中，而不用在每一个域中都复制一份公式(formula). Org 还提供了一个 formula 调试器和一个 formula 编辑器, 该 formula 编辑器会高亮公式中所引用到的域,并且可以通过方向键来移动该引用.
*** 引用                  :如何引用其他域或区域
    要根据其他域的值来计算表格中的值,公式必须引用到其他域或区间. 域可用通过名称,通过绝对坐标和相对坐标用这三种方式来引用. 要确定某个域的坐标是什么,在这个域中按下'C-c ?'就会在 echo 区域显示出该域的坐标,也可以按下'C-c }'来切换显示坐标网格.

    * 域引用
      在公式中有两种方法来引用其他域中的值. 第一种类似于其他电子表格,你可以用一个字母/数字组合起来表示一个域的引用,例如'B3'的意思是第 3 行的第 2 个域. 然而,Org 更推荐[fn:28]使用另一种更加通用的表示方法,这种表示方法看起来是这样的:
      #+begin_example
         @row$column      
      #+end_example

      列的可以用绝对坐标表示,类似于这样:$1,$2...$N.也可以用相对坐标表示(当前列为基准值)类似于这样:$+1,$-2,$<,$>.其中$<固定表示第一列,$>固定表示最后一列. 另外,你可以用$>>>表示从右往左数第 3 列

      行在计算坐标时,值计算数据行,而 *不算水平分隔行(hline)* .类似于列的表示方法,你可以使用绝对行数来表示,类似于@1,@2...@N,也可以用相对行数来表示,类似于@+3,@-1,@<和@>. 其中@<固定表示表格中的第一行,@>固定表示表格中的最后一行[fn:29].另外你也可用通过与 hline 的相对位置来引用行:@I 引用第一个 hline,@II 引用第二个 hline,一次类推. @-I 引用的是当前行的上一个 hline,@+I 是当前行的下一个 hline. 你也可以通过@III+2 表示第 3 个 hline 的后 2 行

      $0 和$0 分别引用的是当前行和当前列,也就是要被计算的域的行和列. 另外,如果你忽略了引用的行或列部分,默认情况下使用当前域的行或列代替.

      Org 中不带符号只含数字的引用是固定引用,也就是说如果你在两个不同的域中使用同一个引用表示法,引用的是同一个域. 而 org 中带符号和数字的引用是浮动引用,即相同的引用表示法可能引用的是不同的域,这取决于公式所在的那个域的位置.

      下面是一些例子:
      #+begin_example
              
        @2$3      2nd row, 3rd column (same as C2)
        $5        column 5 in the current row (same as E&)
        @2        current column, row 2
        @-1$-3    the field one row up, three columns to the left
        @-I$2     field just under hline above current row, column 2
        @>$5      field in the last row, in column 5
        
      #+end_example

    * 区间引用
      
      你可以引用一个矩形区间,方法是指明两个域引用,并用'..'连接起来. 如果这两个域都处于同一个行,可用只使用'$2..$7'这样来代替, 但若至少有一个域处于不同的行,那么你需要对至少第一个域使用完整的@row$column 格式(即引用必须以@开头,以便能够正确第解释).例如
      #+begin_example
              
        $1..$3        first three fields in the current row
        $P..$Q        range, using column names (see under Advanced)
        $<<<..$>>     start in third column, continue to the one but last
        @2$1..@4$3    6 fields between these two fields (same as A2..C4)
        @-1$-2..@-1   3 numbers from the column to the left, 2 up to current row
        @I..II        between first and second hline, short for @I..@II
        
      #+end_example

      区间引用返回一个值的 vector(向量),并传入 Calc 向量函数中执行. 区间中的空域正常来说都会被忽略掉,这样向量中就只包含了非空域(要切换这种行为,参见下面的'E' mode).如果区域中所有的域都为空域,那么就会返回'[ 0 ]'一次来避免公式中发生语法错误.

    * 公式中的域坐标

      若要在 Calc 公式使用当前域的行号和列号,可用用@#和$#来表示. 在传统的 Lisp 公式中等价于'org-table-current-dline'和'org-table-current-column'.例如:
      #+begin_example
              
        if(@# % 2, $#, string(""))   column number on odd lines only
        $3 = remote(FOO, @@#$2)      copy column 2 from table FOO into
                                     column 3 of the current table
        
      #+end_example

      对于第二个例子,FOO 表格至少需要有与当前表格一样多的行. 注意:这对于大量的行操作来说是很不效率的[fn:30].

    * 命名引用
      '$name'会被被解释成列名，参数或者常量. 可以通过变量'org-table-formula-constants'来定义全局常量,或者通过类似下面一行的方法来为某个文件定义本地常量.
      #+begin_src org
        ,#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6
      #+end_src
      
      另外,在表格公式中,也可以使用属性(参见章节[[#Properties and columns][属性与列]])来作为常量使用[fn:31]:你可以通过名为'$PROP_ Xyz'的常量来访问属性':Xyz:',Org 会在表格所在大纲条目及其上级条目中搜索该属性. 如果你加载了'constants.el'这个包,那么 Org 也会使用这个包来匹配常量,这个包甚至包括自然常量(例如$h 表示普朗克常量)和单位(例如$km 表示千米). 列名和参数可以在一个特殊的表格行内指定,更具体描述以后再说,可以参见[[#Advanced features][高级特性]].现阶段所有的名字都必须以字母开头,以后可能可以以字母和数字开头.

    * 远程引用
      你也可以引用其他表格中的常量,域和区间, 这些表格可以在同一个文件也可以在不同文件中. 引用的方法为
      #+begin_src org
        ,        remote(NAME-OR-ID,REF)
      #+end_src
      这里 NAME 可以是当前文件中当前表格以前所定义的表格名字. 这里表格名字可以用'#+TBLANAME:表格名字'来定义. NAME 的值也可以是某个大纲条目的 ID(甚至可以是其他文件中的大纲条目),这时引用的就是该条目中的第一个表格. REF 是一个绝对域或绝对区间的引用(具体方法如上面所示,例如@3$3 或者$somename,这些绝对引用需要确保在被引用表格中都是可用的).

*** Calc 的公式语法         :使用 Calc 计算
    一个公式可用是任何能够被 Emacs 的'calc'包所识别的代数表达式. *注意,在'Calc'中,'/'的操作符优先级要比'*'低,因此'a/b*c'会被解释为'a/(b*c)',这一点与标准不符*. 在 calc-eval(参见 GNUEmacs Calc　Manual 中'Calling Calc from Your Lisp Programs'章节的)进行计算之前,变量替换会以之前所描述的方式发生. 公式之中的区域变量可用直接放入 Calc 的向量函数(例如'vmean'和'vsum')中作为参数使用.

    公式可用在分号之后附加上可选的选项模式字符串. 这种选项模式字符串由标志所组成,这些标志会在公式被执行时影响 Calc 和其他模式. 默认情况下,Org 使用标准的 Calc 模式(精度为 12 位,角度单位为度,分数和 symbolic 模式为关闭状态). 然而,公式在显示时,会自动调整为(float 8)以便保持表格的紧凑. 可用通过变量'org-calc-default-modes'来配置这些默认设置
    #+begin_example
      p20           set the internal Calc calculation precision to 20 digits
      n3 s3 e2 f4   Normal, scientific, engineering, or fixed
                    format of the result of Calc passed back to Org.
                    Calc formatting is unlimited in precision as
                    long as the Calc calculation precision is greater.
      D R           angle modes: degrees, radians
      F S           fraction and symbolic modes
      N             interpret all fields as numbers, use 0 for non-numbers
      E             keep empty fields in ranges
      L             literal
    #+end_example
    除非你使用大整数或高精度计算式,并且需要显示浮点式数字,你可以提供一个 printf 格式说明字符串[fn:32]来对 Calc 计算并传回 Org 的结果进行重新格式化,而不是 Calc 自己作这种格式化. 下面是一些例子
    #+begin_example
      $1+$2                Sum of first and second field
      $1+$2;%.2f           Same, format result to two decimals
      exp($2)+exp($1)      Math functions can be used
      $0;%.1f              Reformat current cell to 1 decimal
      ($3-32)*5/9          Degrees F -> C conversion
      $c/$1/$cm            Hz -> cm conversion, using ‘constants.el’
      tan($1);Dp3s1        Compute in degrees, precision 3, display SCI 1
      sin($1);Dp3%.1e      Same, but use printf specifier for display
      vmean($2..$7)        Compute column range mean, using vector function
      vmean($2..$7);EN     Same, but treat empty fields as 0
      taylor($3,x=7,2)     Taylor series of $3, at x=7, second degree
      
    #+end_example

    Calc 还包含了一个完整的逻辑操作集合. 例如
    #+begin_example    
      if($1<20,teen,string(""))            如果第一列(age 列)比 20 小,则返回值"teen",否则返回空值
    #+end_example
    
    注意,在计算时长时,还可以使用两个特定的标志 T 和 t,具体参见[[#Durations and time values][时长与时间]]
*** Emacs Lisp 写成的公式   :使用 Emacs Lisp 来写公式
    你可以使用 Emacs Lisp 来写公式;这在当 Calc 提供的函数不足与实现我们期望的操纵字符串和控制结构的功能时非常有用. 如果一个公式是以单引号后跟一个开括号开头的,则该公式被认为是 Lisp 形式的. 该 Lisp 的运算结果应该是返回一个字符串或者是数字的. 就像使用'calc'公式一样,你可以在分号';'后面指定模式和 printf 格式. 使用 Emacs Lisp 形式,你需要关注域引用插入到 form 中的方式. 默认情况下,一个引用是将域中的值以字符串的形式(包括在双引号内)插入的. 如果开启了 M 模式,则所有的被引用元素都会被转化为数字(非数字域转化为 0)并且在插入时作为 Lisp 数字型插入(不包含引号). 如果你提供了'L'标志,所有的域将会以字面上的方式(不包含引号)插入公式中. 也就是说,如果你想一个引用作为字符串来插入到 Lisp 形式的公式中,则使用双引号来包含引用表达式(例如"$3")即可. 区域在插入时会作为一系列以空格分隔的域,这样你就可以把它们潜入 list 或 vector 符号中. 下面是一些例子--注意我们在用 Lisp 计算时是如何使用'N'模式的
    #+begin_example
          
      Swap the first two characters of the content of column 1
        '(concat (substring $1 1 2) (substring $1 0 1) (substring $1 2))
      Add columns 1 and 2, equivalent to Calc's $1+$2
        '(+ $1 $2);N
      Compute the sum of columns 1-4, like Calc's vsum($1..$4)
        '(apply '+ '($1..$4));N
      
    #+end_example
*** 时长和时间的值          :如何计算工期和时间的值
    如果你希望计算的是时间的值,你需要在 Calc 公式或 Elisp 公式中使用 T 标志
    #+begin_src org
      ,  |  Task 1 |   Task 2 |    Total |
      ,  |---------+----------+----------|
      ,  |    2:12 |     1:47 | 03:59:00 |
      ,  | 3:02:20 | -2:07:00 |     0.92 |
      ,  #+TBLFM: @2$3=$1+$2;T::@3$3=$1+$2;t
      , 
      
    #+end_src
    输入的时长值必须是以[HH:MM[:SS]]的形式的,这里秒数是可选的. 当使用了 T 标志,计算出来的时长会以 HH:MM:SS 的形式来显示(参见上面例子的第一个公式). 当使用 t 标志时,计算出来的时长的显示方式是根据变量'org-table-duration-custom-format'的不同而不同的, 该变量默认单位为小时并且会以小数的形式来显示结果(参见上面的第二个公式).

    Org 也支持副的时长,而且数字在作加减法时会被认为是秒数.
*** 域公式和区间公式        :给某个域或某个区间分配一个公式
    要给一个域分配公式,直接输入公式,并在前面加上':=',例如':vsum(@II..III)'. 当你在 *光标还在域中时* 按下<TAB>或<RET>或 C-c C-c,公式就会被保持在该域中,并且会自动计算并把计算结果展示为域的值.

    公式是统一存储在一个特殊行中的,该行是以"#+TBLFM:"开头的,并且直接就在表格的下方紧靠表格. 如果你在第 3 行的第 4 个域中输入公式,那么该公式就会类似于'@3$4=$1+$2'这样. 当使用命令插入/删除/交换了行或者列时,公式中的绝对引用(但是不包括相对引用)也会跟着改变,以保证引用还是指向与修改前同一域. 要避免这种情况发生(特别是在公式中使用了区间引用,表格的边界引用(使用@<,@>,$<,$>)或 hlines 引用(使用@I 符号)的情况下), 你需要使用一般的编辑命令来改变表格结构.当使用一般的编辑命令来修改表结构的情况下,域引用的这种自动适配功能当然是不会发生的--这样的话,你需要自己修正公式.

    除了直接在域中输入公式,你也可以使用下面这些命令
    * C-u C-c = (org-table-eval-formula) ::
         为当前域分配一个新的公式. 该命令提示你输入公式(默认值为从#+TBLFM:行中获得公式),然后应用该公式到当前域并保持起来.

         在公式的左侧也可以是特别的表达式,以这种方法可用为一系列不同的域分配公式. 并没有快捷方式来输入这种区间公式. 要增加这种区间公式,需要使用公式编辑器(参见[[#Editing and debugging formulas][编辑和调试公式]])或者直接编辑$+TBLFM:行

    * $N= (这里 N 表示第几列) ::  
	     列公式,对整个列生效. 这种公式如此常见以至于 Org 以一种特殊的方式来处理这些公式,参见[[#Column%20formulas][列公式]]

    * @N= (这里 N 表示第几行) :: 
	     行公式,对一行的所有域生效. @>=表示最后一行.

    * @1$2..@4$3= :: 
		    区间公式,对所指定的矩阵区间内的所有域有效. 这可以用来分配公式给行中的一些域(但不是所有的域)

    * $name= :: 
		命名域,具体参见[[Advanced features][高级特性]]
*** 列公式                 :对整个列都生效的公式
    #<<Column formulas>>
    当你分配一个列公式到一个列时(使用类似$3=这样的语法),该列的所有域都会使用同一个公式,然而也会有一些例外:(i) 如果表格包含了水平分隔行 hlines,任何在第一个水平分隔行之前的行都被认为是表头信息,因此就不会被列公式所改变. (ii) 如果一个域已经定义了域公式或区间公式,那么它也被列公式排除在外(即域公式和列公式的优先级高于列公式). 上诉的两个条件使得列公式很容易使用.

    要分配一个列公式给某个列,直接输入公式到该列的任何一个域中,并在前面加一个-号,就像这样'=$1+$2'. 当你在光标还在域的情况下按下<TAB>或<RET>或 C-c C-c, 输入的公式就会作为该列的列公式而存储起来,然后经过计算,把结果在当前域(而不是当前列)中展示出来. 如果列中的某个域只包含'=',那么该列中前一个存储起来的公式会被应用到该域中. 对于每个列来说,Org 只会记住最近使用的那个公式. 在'#+TBLFM:'行,列公式看起来类似于'$4=$1+$2'这样. 列公式的左边不能是列的名字,它必须是数字形式的列引用或$>

    除了输入以=开头的公式到域中,你也可以使用下面的命令来创建列公式
    * C－c = (org-table-eval-formula) ::
         为该列应用一个新的列公式,然后使用该公式的计算结果显示在当前域中. 该命令会提示你输入列公式,默认值为#+TBLFM 行的公式. 输入的列公式会应用到当前域中并存储起来. 如果加上一个数字前缀(例如 C-5 C-c =),该命令会应用到当前列中连续 N 个域中.
*** 编辑和调试公式          :修正公式
    你可以在 minibuffer 或者直接在域中编辑一个个的公式. Org 也可以准备一个包含表格中所有公式的特殊缓存区. 当对公式进行编辑时,Org 在可能的情况下会转换引用为标准格式(类似于 B3 或者 D&这样的引用). 如果你想只使用引用内部格式(类似于@3$2 或者$4),请配置变量'org-table-use-standard-references'

    * C-c = 或者 C-u C-c = (org-table-eval-formula) ::
         在 minibuffer 中编辑当前列/域的公式. 参见[[#Column formulas][列公式]]和[[#Field and range formulas][域与区间公式]].
    * C-u C-u C-c = (org-table-eval-formula) :: 
	 为当前域重新设定一个公式(可以使域公式也可以是列公式),使用这个命令你可以直接在域中编辑公式. 与在 minibuffer 中编辑公式相比,这种方法的优势在于你可以使用命令 C-c ?查询域的信息.
    * C-c ? (org-table-field-info) :: 
	 当在表格域中编辑公式时,高亮公式中鼠标所在位置的域引用所引用的域.
    * C-c } :: 
	       切换显示行列编号,using overlays(org-table-toggle-coordinate-overlays). 这些信息在每次表格重排之后都会自动更新;你也可以使用 C-c C-c 来强制更新信息.
    * C-c } :: 
	       切换开启或者关闭公式调试器(org-table-toggle-formula-debugger). 具体信息参见下面
    * C-c ' (org-table-edit-formulas) :: 
	 打开一个特殊的缓冲区(公式编辑器),可以在里面编辑当前表格所有的公式,在这个缓冲区中,每个公式都显示一行. 如果当前域包含包含有一个激活的公式,公式编辑器中的光标会标示出它来. 当光标在这个特殊的缓冲区中时,Org 会自动高亮任何光标位置的域引用所引用的域. 你可以在这个特殊缓冲区中使用下面这些命令来编辑,删除和新增公式
      * C-c C-c 或 C-x C-s (org-table-fedit-finish) ::
	   退出公式编辑器,并且保持修改后的公式. 如果加了 C-u 前缀,那么会对整个表格应用新修改的公式(表格中所有的公式都会被重新计算一遍,然后显示出来)
      * C-c C-q (org-table-fedit-abort) :: 
	   退出公式编辑器,而不做任何修改
      * C-c C-r (org-table-fedit-toggle-ref-type) :: 
	   对表格编辑器中的所有引用切换显示格式,在标准格式(类似于 B3)和内部格式(类似于@3$2)间切换
      * <TAB> (org-table-fedit-lisp-indent) :: 
	   美化并缩进当前光标所在的 Lisp 公式. 当光标所在行包含有 Lisp 公式时,使用 Emacs Lisp 的规则来格式化公式. Another <TAB> collapses the formula back again. 在 open formula(开放式公式??)中,<TAB>跟在 Emacs Lisp mode 一样起着重新缩进的功能.
      * M-<TAB> (lisp-complete-symbol) :: 
	   补完 Lisp 符号,就跟在 Emacs Lisp mode 中一样
      * S-<up>/<down>/<left>/<right> :: 
	   切换光标所在的引用. 例如如果现在光标所在的引用是 B3,你按下 S-<right>之后,该引用变成了 C3. 这对相对引用和 hline 引用也有效
      * M-S-<up> (org-table-fedit-line-up) 或 M-S-<down> (org-table-fedit-line-down) :: 
	   上下移动 Org buufer 中行公式的 test line
      * M-<up> (org-table-fedit-scroll-down> 或 M-<down> (org-table-fedit-scroll-up) :: 
	   滚动表格所在的窗口
      * C-c } :: 
		 显示/关闭表格中各个域的坐标
    把一个域清空并不会删掉这个域的公式,因为公式实际上是保存在其他行(#_TBLFM 行)-这样在下一次重新计算时,该域又会有新的值初出现. 要删掉一个域中的公式,你需要在编辑公式要求输入新公式时输入一个空回复,或者直接编辑#+TBLFM 行

    你可以直接编辑'#+TBLFM'行,然后在该行运行 C-c C-c 来对改变后的公式进行重新计算.或者也可以在表格中执行普通的重计算命令.

    *调试公式*

    当公式的计算产生错误时,域中的内容变为字符串'#ERROR'. 如果你想知道在变量替换和计算时都发生了什么以便寻找 bug,你可以在 Tbl 菜单上打开公式调试功能然后重新对改公式计算一次(在域中按下 C-u C-u C-c = <RET>).随后就会显示详细信息出来.
*** 更新表格               :重新计算所有相关域
    表格一般来说不会自动进行重计算,而是需要通过命令来触发. 要想使表格半自动地进行重计算,请参见[[#Advanced features][高级特性]],

    要想对整个表格或者一整行进行重新计算,可用使用下面的命令:
    * C-c * (org-table-recalculate) ::
         重新计算当前行,计算的方法是首先从左到右对该行的每个域都计算一次列公式,然后再当前行的域公式和区间公式.
    * C-u C-c * 或 C-u C-c C-c :: 
	 一行一行地重新计算整个表格. 任何在第一个 hline 之前的行都被认为是表头而排除在重计算操作之外
    * C-u C-u C-c * 或 C－u C-u C-c C-c (org-table-iterate) :: 
	 重复对表格进行重计算,直到没有变化可以继续产生. 如果有些域的计算结果依赖于其他域的值,而这些被依赖的域的值需要在指向了一系列的计算之后才能得到的时候,这时候这项功能就很有必要了.
    * M-x org-table-recalculate-buffer-tables :: 
	 重新计算当前缓冲区中的所有表格
    * M-x org-table-iterate-buffer-tables :: 
	 对当前缓冲区中的所有表格进行迭代计算,以便 converge(汇聚??)表与表之间的依赖关系.
*** 高级特性               :域和列的名字,参数和自动重计算
    #<<Advanced features>>
    如果你想自动重计算域的值,或者你向为域和列分配名字[fn:33],你需要保留表格的第一列作存放特殊的标志字符.

    * C-# (org-table-rotate-recalc-marks) ::
         使第一列的标志字符在' ','#','*','!','$'这几个状态之间切换. 如果存在一个激活的块,则会改变该块中所有的标志.

    下面的例子是一个记录学生考试成绩的表格,里面用到了这些特性:
    #+begin_src org
      ,|---+---------+--------+--------+--------+-------+------|
      ,|   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |
      ,|---+---------+--------+--------+--------+-------+------|
      ,| ! |         |     P1 |     P2 |     P3 |   Tot |      |
      ,| # | Maximum |     10 |     15 |     25 |    50 | 10.0 |
      ,| ^ |         |     m1 |     m2 |     m3 |    mt |      |
      ,|---+---------+--------+--------+--------+-------+------|
      ,| # | Peter   |     10 |      8 |     23 |    41 |  8.2 |
      ,| # | Sam     |      2 |      4 |      3 |     9 |  1.8 |
      ,|---+---------+--------+--------+--------+-------+------|
      ,|   | Average |        |        |        |  29.7 |      |
      ,| ^ |         |        |        |        |    at |      |
      ,| $ | max=50  |        |        |        |       |      |
      ,|---+---------+--------+--------+--------+-------+------|
      ,#+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f 
    #+end_src

    注意事项:请注意,对于这些特殊的表格来说,使用'C-u C-c *' 来重计算表格,只对标记了'#'或'*'的行,和那些分配了公式的域生效. 列公式对当第一个域为空的行无效.

    这些标志字符的意义如下所示:
    * '!' ::
         该行的域中的值为列的名称,因此你可以使用引用'$Tot'来代替'$6'
    * '^' :: 
	     这一行定义了上一行相应域的名称. 有着这种定义,任何表格中的公式可以使用'$m1'来引用值'10'. 而且如果你为这个命名了的域分配公式,该公式会被存储为'$name=...'的形式
    * '-' :: 
	     类似于'^',但是是为下一行的相应域定义名字的.
    * '$' :: 
	     这一行的域可以为公式定义参数. 举个例子,如果'$'行中的某个域包含了'max=50',则表格中的公式可以使用'$max'来引用 50 这个值. 参数就好像是常量一样,所不同的是它们(参数)能够根据每个表格来定义.
    * '#' :: 
	     当在行中按下了<TAB>或<RET>或 S-,TAB>,所有该标示的行中的域会自动重新计算. 另外当使用全局重计算命令(C-u C-c * )时这些行也会进行重计算,而无标示的行则对该全局重计算命令无效.
    * '*' :: 
	     当使用全局重计算命令(C-u C-c * )时,该标志行也会进行重计算,但是该标志行并不会自动进行重计算. 当自动重计算功能会明显降低编辑效率时,该标志很有用.
    * '' :: 
	    无标志字符的行在使用 C-u C-c * 进行重计算时并不会进行重计算. 只有标示了'#'或'*'的行才会重新计算.
    * '/' :: 
	     不导出带有该标志的行. 对那些包含了 narrowing '<N>'标记(缩小的'<N>'标记)或列的分组标志很有用.

    最后,你可能会对使用梦幻般的'calc.el'包能实现那些功能很感兴趣, 下面是一个表格,它计算了 the Taylor series of degree n at location x for a couple of functions. 
    #+begin_src org
      ,|---+-------------+---+-----+--------------------------------------|
      ,|   | Func        | n | x   | Result                               |
      ,|---+-------------+---+-----+--------------------------------------|
      ,| # | exp(x)      | 1 | x   | 1 + x                                |
      ,| # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |
      ,| # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |
      ,| # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |
      ,| # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |
      ,| * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |
      ,|---+-------------+---+-----+--------------------------------------|
      ,#+TBLFM: $5=taylor($2,$4,$3);n3
      
    #+end_src

** Org-Plot              :org 表格绘图
   通过使用'Gnuplot'[[http://www.gnuplot.info]] 和'gnplot-mode'[[http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html]] ,Org-Plot 可用根据表格中的数据生成 2D 和 3D 图表. 这里有一个例子: 首先确保你安装了 Gnuplot 和 Gnuplot mode,然后对下面的表格调用'org-plot/gnuplot'
   #+begin_src org
     ,#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
     ,| Sede      | Max cites | H-index |
     ,|-----------+-----------+---------|
     ,| Chile     |    257.72 |   21.39 |
     ,| Leeds     |    165.77 |   19.68 |
     ,| Sao Paolo |     71.00 |   11.50 |
     ,| Stockholm |    134.19 |   14.33 |
     ,| Morelia   |    257.56 |   17.67 |
   #+end_src

   注意,Org Plot 会自动把表格的标题作为生成图表的标签. 通过表格前的#+PLOT:行,你还可以定义 plot 的标签,类型,内容和展示. 下面列出了完整的 Org-plot 选项. 更多的信息和例子请参见 Org-plot 教程[[http://orgmode.org/worg/org-tutorials/org-plot.html]]

   *Plot Options*
   * set ::
     当绘图时,用于设置任何的 gnuplot 选项
   * title :: 
	      指定 plot 的标题
   * ind :: 
	    指定表格的哪一列作为 x 轴
   * deps :: 
	     指定描绘哪些列,该设置的格式类似于 Lisp 中的 list,由小括号括起来,内部用空格分隔,例如'dep:(3 4)'指定只描绘第 3,4 列(默认情况下,除了指明为 ind 的列,其他的列都会被描绘)
   * type :: 
	     指定 plot 是 2d 还是 3d 还是 grid 的
   * with :: 
	     对每一个要被绘制的列都插入一个指定的 with 选项(例如,lines,points,boxes,impulses,等等). 默认值为 lines
   * file :: 
	     如果你想将描绘输出成一个文件,指定输出文件的路径
   * labels :: 
	       用一个列表指定各输出列的标签(默认情况下,如果列的标题村爱的话,使用列标题作为标签)
   * line :: 
	     在 gnuplot 脚本中插入指定的一整行(Specify an entire line to be inserted in the Gnuplot script. )
   * map :: 
	    当描绘类型为 3d 或 grid 时,该选项的值设为 t 则在描绘时描绘的是一个平面映射而不是 3 维图形(set this to t to graph a flat mapping rather than a 3d slope)
   * timefmt :: 
		指定 Org-mode 的时间戳格式,因为它们会被 Gnuplot 所解析,默认格式为'%Y-%m-%d-%H:%M:%S'
   * script :: 
	       如果你想实现完全的自定义,你可以指定一个脚本文件(把文件名放在双引号内)来实现描绘动作. 在正真描绘之前,这个特定脚本中的每个'$datafile'会被替换成生成的数据文件的实际路径. 注意:即使你设置了这个选项,你也可能仍然需要定义 plot 的 type,因为这个选项会影响到生成的数据文件的内容.
* 超链接
  类似于 HTML,Org 提供了文件内部的链接,和文件外部的链接(可以链接到其他文件,Usenet 文章,email 等等)
** 链接的格式              :Org 中的链接是什么格式的
   Org 会识别类似 URL 的链接并且把它们作为可点击的链接. 然而,Org 中链接的一般形式看起来像下面这样子
   #+begin_example
   [[链接地址][描述]]  或者 [[链接]]
   #+end_example

   一旦缓冲区中的链接被补完(所有的中括号都有了), Org 会只显示链接中的'描述',而不是链接的完整形式. Link 会以'org-link'定义的方式高亮,默认情况下是以下划线标示起来. 你可以直接编辑链接的显示部分(当有描述部分是为'描述'部分,否则为'链接'部分). 要编辑不可见的'链接'部分,把光标放在要编辑的链接上然后按下 C-c C-l

   如果光标在链接的起始部分或就在链接中显示文本的后面,然后你按下<DEL>或<BACKSPACE>时,你删掉的是链接中不可见的中括号. 这样会使这个链接变得不完整,因此该链接的内部表现形式会以纯文本的方式展现出来. 再补完这个中括号又会使链接隐藏其内部结构. 要显示出所有链接的内部结构,使用菜单'org->hyperlinks->Literal links'
** 内部链接                :链接到同一文件的不同地方
   如果链接看起来不像是 URL,那么它会被认为是链接到当前文件的内部. 最重要的一个例子就是一种看起来像'[[#my-custom-id] ](中间没有空格)'的链接,这种链接会连接到'CUSTOM_ID'属性为'my-custom-id'的条目中. 这种客户化的 ID 在导出为 HTML 时很有帮助(参见[[#HTML export][导出为 HTML]]),通过这些 ID,org 会自动产生许多章节间的链接. 你需要保证这些客户化的 ID 在文件中是唯一的.

   类似于'[[My Target] ]'或'[[My Target][Find my target] ]'会在当前文件中搜索指定文本,并链接过去.

   当光标处于链接上时,可以用 C-c C-o 或鼠标点击(参见[[#Handing links][处理链接]])的方式来进入链接. 连接到客户化 ID 的链接会指向相应的标题. 匹配文本链接的一个比较好的方法是使用 dedicated target:用两个尖括号将文本括起来. 链接标的可以放置在任何地方; 有时候把这些链接标的放置在注释行中会比较好.例如
   #+begin_example
   # <<My Target>>
   #+end_example

   在导出 HTML 时(参见[[#HTML export][导出 HTML]]),这些链接标的会转换为已命名的锚点,可以通过 http 链接[fn:34]直接定位到这些锚点的位置.

   如果没有'dedicated target'存在, Org 会搜索与链接文本完全一样的标题(可能也会搜索 TODO 关键字和标签[fn:35]). 在非 Org 文件中,则会搜索跟链接文本匹配的文本内容. 在上面的例子中,匹配的是'my target'.

   进入一个链接会把一个 mark 放置仅 Org 自己的 mark ring 中. 这样你可以使用 C-c &退回前一个位置. 可以多次使用该命令来退到早期记录的位置上.

   [[Radio targets]] 使得可以触发纯文本形式的链接.
*** Radio targets
    Org 可以自动把普通文本中特定的文本转换为链接. 因此不需要明确地创建链接,这些特定的文本会自动创建连接到带有 radio target 标志的位置. Radio target 包裹在三个尖括号中,就像'<<<My Target>> >(不带空格)'这样. 这个 radio target 使得普通文本中出现'My Target'的地方都被自动转换为链接. 只有在文档第一次加载人 Emacs 时,Org 才会自动去扫描 radio target. 在编辑时要更新 target 列表,可以把光标放到 target 上,然后安歇 C-c C-c
** 外部链接                :类似与 URL 这样的链接,可以链接到全世界
   Org 支持连接到文件,网站,Usenet,email 信息,BBDB 数据库条目,IRC 会议及其日志的链接. 外部链接看起来类似 URL. 这些外部链接是以一个简短的标示串开头后面紧跟冒号(在冒号后面不跟空格).下面是各种类的链接的例子[fn:36]
   #+begin_example
     http://www.astro.uva.nl/~dominik          on the web
     doi:10.1000/182                           DOI for an electronic resource
     file:/home/dominik/images/jupiter.jpg     file, absolute path
     /home/dominik/images/jupiter.jpg          same as above
     file:papers/last.pdf                      file, relative path
     ./papers/last.pdf                         same as above
     file:/myself@some.where:papers/last.pdf   file, path on remote machine
     /myself@some.where:papers/last.pdf        same as above
     file:sometextfile::NNN                    file, jump to line number
     file:projects.org                         another Org file
     file:projects.org::some words             text search in Org file[36]
     file:projects.org::*task title            heading search in Org file
     file+sys:/path/to/file                    open via OS, like double-click
     file+emacs:/path/to/file                  force opening by Emacs
     docview:papers/last.pdf::NNN              open in doc-view mode at page
     id:B7423F4D-2E8A-471B-8810-C40F074717E9   Link to heading by ID
     news:comp.emacs                           Usenet link
     mailto:adent@galaxy.net                   Mail link
     vm:folder                                 VM folder link
     vm:folder#id                              VM message link
     vm://myself@some.where.org/folder#id      VM on remote machine
     wl:folder                                 WANDERLUST folder link
     wl:folder#id                              WANDERLUST message link
     mhe:folder                                MH-E folder link
     mhe:folder#id                             MH-E message link
     rmail:folder                              RMAIL folder link
     rmail:folder#id                           RMAIL message link
     gnus:group                                Gnus group link
     gnus:group#id                             Gnus article link
     bbdb:R.*Stallman                          BBDB link (with regexp)
     irc:/irc.com/#emacs/bob                   IRC link
     info:org#External links                   Info node link
     shell:ls *.org                            A shell command
     elisp:org-agenda                          Interactive Elisp command
     elisp:(find-file-other-frame "Elisp.org") Elisp form to evaluate 
   #+end_example
   要自定义 Org 以支持新的链接类型,参见[[#Adding hyperlink types][新增链接类型]]

   一个链接应该被两个中括号括住,并且可以包含一个描述文本,这个描述文本会代替 URL 显示给用户看(参见章节[[#Link format][链接类型]]),例如:
   #+begin_src org
     ,[[http://www.gnu.org/software/emacs/][GNU Emacs]]
   #+end_src

   如果描述部分是一个文件的名字或者是一个连接到图像的链接,HTML 导出时(参见[[#HTML export][导出 HTML]])会内嵌入这个图像并显示为一个可点击的按钮. 如果链接中根本没有定义描述而定义的 link 是指向一个图形文件的,那么这个图形文件会被内嵌入导出的的 HTML 文件中.

   Org 也会在普通文本中查找外部链接并且把它们当做真正的链接处理. 如果 link 部分包含有空格(例如'bbdb:Richar stallman'),或者如果你需要明确 link 的结尾位置所在,你可以把它们放入方括号中.
** 链接处理                :创建,插入和进入链接
   Org 提供了多种方法来创建和跟踪链接
   * C-c l (org-store-link) ::
	 在创建一个连接到当前位置的链接. 这是一个全局命令(你需要自己创建绑定热键),你可以用它在任一个 buffer 中创建指向自己的连接. 这个被创建出来的链接可以随后插入到 Org-mode 的 buffer 中保存起来(见下文). 具体创建的是哪个类型的链接由当前 buffer 的类型来决定
	 * Org-mode buffer
	   对于 Org 文件来说,若光标位于'<<>target>'处,则创建的链接指向该 target. 否则链接指向当前的 headline,同时以 headline 作为链接中描述部分的内容[fn:37]

	   如果 headline 有 CUSTOM_ID 属性的话,会创建一个连接到该客户化 ID 的链接. Org 会创建一个全局唯一的 ID,并根据 org-link-to-org-use-i 的值新增一条指向该 ID 的链接/替换原有的自定义 ID. 因此在 Org buffer 中使用这个命令有可能会创建两个链接,一个指向可读的自定义 ID,一个指向全局唯一的链接,这个全局唯一的链接即使在原条目被移动到其他文件后也是可用的. 随后当你要把链接插入 Org 文件时,你需要决定插入哪个链接.

	 * Email/News 客户端:VM,Rmail,Wanderlust,MH-E,Gnus
	   在很多 Emacs 邮件客户端 buffer 使用这个命令时,产生的链接会指向当前的邮件,甚至,在某些 GNUS buffer 中,可用指向分组. 邮件的作者和标题会作为链接的描述信息

	 * Web 浏览器:W3 和 W3M
	   生成的链接连接到当前的 URL,网页 title 作为链接的描述信息

	 * Chat:IRC
	   对于 IRC 链接来说,如果你设置变量 org-irc-link-to-logs 的值为 t,那么创建的链接指向当前会话的日志,链接的形式类似于'file:/'. 否则的话,创建的链接指向当前用户/频道/服务器,链接的形式为'irc:/'

	 * 其他类型的文件
	   对于其他类型的文件,创建的链接指向该文件,同时链接会有一个搜索字符串(参见[[#Search options in file links][指向文件链接的搜索项]])指向当前行的内容.
   * C-c C-l (org-insert-link) :: 
	 插入一个链接[fn:38].它会提示你输入一个链接,并将这个链接插入到当前的 buffer 中. 你可以输入上面例子中提到的任何类型的链接.随后系统会让你输入链接的描述文本并将生成的链接插入到 buffer 中[fn:39]. 如果在调用该命令时选中了一些文本,那么选中的文本会成为默认的描述文本呢
	 * 插入存储过的链接
	   所有在当前会话期存储过的链接都会记录到该命令提示的历史信息中,因此,在提示符中你可以用<up>和<down>(或者 M-p/n)来切换历史链接信息

	 * 支持补全
	   如果你要插入的链接前缀类似于'http:'或'ftp:',你可用通过按<TAB>键来自动补全.比如你可以只写链接的简写形式,然后按 TAB 键扩充它(参见[[#Link%20abbreviations][链接的缩写]]).如果你在输入前缀部分之后直接按<RET>,Org 会根据前缀的不通为各种不通类型的链接提供不通的补全模式[fn:40].例如,如果你输入`file <RET>`,就会进入文件路径补全状态(另一种进入该状态的方式是用 C-u C-c C-l,见下文),而如果你输入`bbdb <RET>`,就会进入联系人名称补全的状态
   * C-u C-c C-l  :: 
	 插入一个指向本地文件的链接,你可以使用文件路径的补全功能来补全文件路径. 若插入的文件路径为相对路径,则该相对路径是相对与正在编辑的 Org 文件的目录来说的.你可以用`~/`代替你的 home 目录. 你也可用通过两个 C-u 前缀来强迫插入的链接为绝对路径
   * C-c C-l :: 光标需要停在链接上
	 当光标停在链接上时,C-c C-l 允许你编辑链接的连接和描述信息
   * C-c C-o (org-open-at-point) :: 
		打开光标所在的链接,Org 会使用 web 浏览器(由值 browse-url-at-point 定义)打开 URL,
        会使用 VM/MH-E/Wanderlust/Gnus/BBDB 打开相应的链接,
        若链接为 shell 链接还会在在 shell 中执行链接中的命令. 
        若链接为内部链接,该命令会进行相应的搜索操作. 
        若光标出于标题的 TAG 列表处,则会创建相应的 TAGS 视图. 
        如果光标处于时间戳上,它会为该日期生成一个 agenda. 
        另外如果光标处于'file:'类型的链接处,它会打开链接所指向的文件,如果指向的文件是远程文件或文本文件则直接用 Emacs 打开,如果是本地的非文本文件,则命令会挑选合适的程序打开. 命令是根据文件的扩展名来识别文件类型的. 哪种文件用哪种程序打开由 org-file-apps 选项配置. 如果你想用 Emacs 代替默认的程序来打开链接指向的文件,使用 C-u 前缀执行该命令. 而如果你不想用 Emacs 打开链接所指向的文件,使用 C-u C-u 前缀来调用该命令.
		如果光标位于 headline 处,而这个 headline 刚好又不是个链接,则命令会搜索该 headline 下的所有链接并显示给你选择打开哪个链接.
		如果你想 setup the frame configuration for following links ,配置 org-link-frame-setup 变量
   * <RET> :: 
			  若设置了'org-return-follows-link'值,<RET>也会打开光标所在的链接
   * 鼠标右键 鼠标左键 :: 
		在链接上单击鼠标右键,则会像执行了 C-c C-o 一样的打开链接. 在 Emacs22 或更高版本上,鼠标左键也能打开链接
   * 鼠标中间键 :: 
				   类似于鼠标右键,但是强制使用 Emacs 打开链接,如果链接是内部链接,那么会在另一个窗口显示链接内容[fn:41]
   * C-c C-x C-v (org-toggle-inline-images) :: 
		切换是否内联显示连接的图片. 正常情况下,它只会内联哪些在链接中没有描述信息的图片,比如那些在导出时会内联的图片. 如果执行该命令时加了一个前缀参数,则命令也会显示那些有描述信息的链接图片. 通过配置变量`org-startup-with-inline-images`[fn:42]你也可以让 emacs 在一打开 org 的时候就内联显示图片.
   * C-c % (org-mark-ring-push) :: 
		把当前位置压入 mark ring 中,以方便以后方便跳回该位置. 那些打开链接的命令都会自动执行这一步
   * C-c & (org-mark-ring-goto) :: 
		跳回一个已经记录了的位置. 在访问内部链接和执行`C-c %`命令时都会记录下位置信息. 连续使用该命令多次可用跳到 mark ring 中更远的记录位置处
   * C-c C-x C-n (org-next-link) / C-c C-x C-p (org-previous-link) :: 
		跳到该 buffer 下一个/前一个链接处. 当到达 buffer 的最后一个/第一个链接处时,在执行该命令,第一次会显示失败,之后就跳到最后一个/第一个链接处继续搜索. 这两个命令的绑定键确实太长了;你可能希望用 C-n 和 C-p 来绑定:
		#+BEGIN_SRC elisp
          (add-hook 'org-load-hook
            (lambda ()
              (define-key org-mode-map "\C-n" 'org-next-link)
              (define-key org-mode-map "\C-p" 'org-previous-link)))
		#+END_SRC

** 在 Org 外使用链接         :从我的 C 源码中链接过来的?
   不仅在 Org 模式中,在其他模式下你也可以插入和进入使用 Org 语法标示的链接. 要做到这一点,你可以就像下面所示创建两个全局命令(你可以选择自己喜欢的全局键)
   #+begin_src emacs-lisp
     (global-set-key "\C-c L" 'org-insert-link-global)
     (global-set-key "\C-c o" 'org-open-at-point-global)
   #+end_src
** 链接的缩写              :复杂链接的缩写形式 <<Link abbreviations>>
   长 URL 输起来很麻烦,而且很多时候在文档中需要插入很多类似的链接. 这个时候你就可以使用链接缩写的功能了. 一个缩写的链接看起类似于
   #+begin_src org
     ,[[linkword:tag][description]] 
   #+end_src
   这里 tag 是可选的. linkword 必须是一个 word,以字母开头后面跟着字母,数字,'-'和'_'. Org 根据变量'org-link-abbrev-alist'中的信息来分析缩写. 该变量把 linkword 与替代的文本关联起来.下面是个例子
   #+begin_src emacs-lisp
     (setq org-link-abbrev-alist
       '(("bugzilla" . "http://10.1.2.9/bugzilla/show_bug.cgi?id=")
         ("google"   . "http://www.google.com/search?q=")
         ("gmap"     . "http://maps.google.com/maps?q=%s")
         ("omap"     . "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")
         ("ads"      . "http://adsabs.harvard.edu/cgi-bin/nph-abs_connect?author=%s&db_key=AST"))) 
   #+end_src
   如果被替代的文本中包含字符串'%s', 字符串'%s'会被 tag 所取代. 否则 tag 会直接浮在字符串后面并以此来创建一个链接. 你也可以指定一个函数来创建链接,该函数要求只接受 tag 这唯一一个参数.

   通过上面的设置,你可以使用'[[bugzilla:129] ](不含空格)'来连接到一个指定的 bug, 使用'[[google:OrgMode] ]'来在 web 上搜索'OrgMode',使用'[[gmap:51 Franklin Street,Boston] ]'显示自由软件组织在地图上的位置,使用'[[omap:Science Park 904, Amsterdam, The Netherlands] ]'来显示 Carsten office 在地图上的位置,使用'[[ads:Dominik,C] ]'来查找 Org 的作者在 Emacs hacking 时做了什么.

   如果你只需要为单独一个 Org buffer 指定缩写,你可以在文件中定义:
   #+begin_src org
     ,#+LINK: bugzilla  http://10.1.2.9/bugzilla/show_bug.cgi?id=
     ,#+LINK: google    http://www.google.com/search?q=%s 
   #+end_src
   在'['之后可以使用 In-buffer 补完功能来补完缩写. 你也可以定义一个名为'org-PREFIX-complete-link'的函数,该函数实现对使用 C-c C-l 插入的链接的特定支持动作(例如补完动作). 这个函数不接受任何参数并且返回带前置的完整链接.
** 文件链接中的搜索选项     :链接到特殊的位置
   连接到文件的链接(文件链接)可以包含附加的信息来让 Emacs 在进入链接时跳转到文件的指定位置. 这个附加信息是放置在双[fn:43]冒号(::)之后,它可以是行号或者是搜索项. 例如当用 C-c l 创建一个连接到文件的链接时(参见章节[[#handling links][处理链接]]), 这个链接会编码一个单词到当前行中,这个单词作为搜索字符串,当用 C-c C-o 进入链接时,就可以根据这个搜索字符串找回这一行.

   下面是一些例子,演示了添加搜索项到文件链接的不同方式.
   #+begin_example
     [[file:~/code/main.c::255]]
     [[file:~/xx.org::My Target]]
     [[file:~/xx.org::*My Target]]
     [[file:~/xx.org::#my-custom-id]]
     [[file:~/xx.org::/regexp/]] 
   #+end_example

   * 255 ::
        跳转到第 255 行
   * My Target :: 
		  搜索链接项<<My Target>>,或者直接文本搜索'my target', 类似于文件内链接的搜索,参见[[#Internal links][内部链接]]. 在导出 HTML 时(参见章节[[#HTML export][导出 HTML]]),这种文件链接会导出为 HTML 链接,连接到被连接文件的指定 anchor 处.
   * *My Target :: 
		   在 Org 文件中,精确搜索名为为 My Target 的标题
   * #my-custom-id :: 
		      连接到 CUSTOM_ID 属性值为 my-custom-id 的标题
   * /regexp / :: 
		 使用 regexp 做正则搜索. 该命令使用 Emacs 命令 occur 来在新窗口中列出所有的匹配项. 如果被连接文件处于 Org 模式下,org 会使用 org-occur 命令来创建这些匹配的 sparse tree

   作为简化,一个文件名为空的文件连接,默认是连接到当前文件的. 例如'[[file:::find me] ]'(没有空格),会在当前文件中搜索'find me',就好像'[[find me] ]'一样.
** 客户化搜索              :当内置的搜索不够用的时候
   文件链接中的字符串搜索的默认实现并不能在所有情况下都能正常工作. 例如,BibTex 数据库文件有很多类似于'year="1993"'这样的条目,由于 BibTex 条目的唯一识别就是引用的键值(key),因此这些条目可能不能很好地进行字符串搜索(??意思可能是当对 BibTex 数据库进行搜索时,只希望在 key 中搜索,而不在 value 中搜索)

   如果你遇到了这样的问题,你可以为特定的文件类型指定客户化的函数来实现正确的字符串搜索. 使用 add-hook,这些函数需要添加到 hook 变量'org-create-file-search-functions'和变量'org-excute-file-search-functions'中. 要了解更多的信息可以参见这两个变量的 docstring. org 实际上使用这里定义的实现来对 BibTex 数据库文件进行搜索,你可以参见文件'org-bibtex.el'作为一个实现的例子.
* TODO 事项
  Org-mode 并不把 TODO 列表作为单独的一种文档来看待[fn:44]. 相反,由于在记录的时候常常会有 TODO 事项发生,因此 TODO 事项被认为是记录文件中中不可分割的一部分! 使用 Org 可用很容易的把各级条目标记为 TODO 事项. 通过这种方法,可用避免信息的重复,同时 TODO 事项的整个内容也是可见的

  当然,这种方式组织的 TODO 事项就会分散在你的记录文件的各个地方. Org-mode 通过提供各种函数(这些函数能够告诉你待办事项的这个概览情况)来补偿这一点.
** 最基本的 TODO 功能         :标记和显示 TODO 事项
   任何以·TODO·卡头的标题都被认为是 TODO 事项，例如
   #＋BEGIN_SRC org
:   *** TODO Write letter to Sam Fortune
   #＋END_SRC
   关于 TODO 事项最重要的命令有：
   * C-c C-t (org-todo) ::
	 让当前事项的 TODO 状态在`无` `TODO`和`DONE`之间切换
	 在 timeline 和 agenda 缓存区中,使用 t 命令键也能够实现这样的切换(参见[[#Commands in the agenda buffer][agenda 缓存区中的命令]])
   * C-u C-c C-t :: 
					使用补全方式或快速选择界面(需要设置)来选择特定的 TODO 关键字, 若要使用快速选择界面,你需要給每个 TODO 状态分配快捷键,更多信息,参见[[#Setting up keywords for individual files][为各个文件分配 TODO 关键字]]和[[#Setting tags][设置 tags]]
   * S-<right>  /  S-<left> :: 
		循环选择下一个/上一个 TODO 状态. 在事项有超过两个 TODO 状态的时候最有用(参见章节[[#Extended use of TODO keywords][扩展 TODO 关键字]]). 要了解`shift-selection-mode`对改名了的而影响,参见章节[[#Packages that lead to conflicts with Org mode][与 Org mode 冲突的包]].参见变量`org-treat-S-cursor-todo-selection-as-state-change`变量的说明
   * C-c / t (org-show-todo-key) :: 
		在一个[[#sparse tree][sparse tree]]中查看 TODO 事项. 这回折叠起整个 buffer 只显示所有的未完成事项及其标题. 在命令前加上前缀(C-u C-c / t)可用搜索指定的 TODO 状态,你会被要求输入需要搜索的 TODO 状态(可用'KWD1|KWD2'的形式输入多个 TODO 状态),命令会列出匹配的所有事项. 如果调用该命令时附加了一个数字型的前缀参数 N,则会匹配变量`org-to-keywords`中的第 N 个 TODO 状态. 如果调用该命令时加了两个前缀参数,则所有未完成和已完成的事项都会被找出来
   * C-c a t (org-todo-list) :: 
		显示全局的 TODO 列列表,从所有加入 agenda 的文件(参见[[Agenda views][Agenda 视图]])中收集所有的未完成事项到一个缓冲区中. 这个新 buffer 会处于 agenda-mode,agenda-mode 提供了很多命令来查看,操作 buffer 中的这些 TODO 事项(参见章节[[#Commands in the agenda buffer][agenda buffer 中的命令]]). 更多信息请见章节[[#The global TODO list][全局代办列表]]
   * S-M-<RET> (org-insert-todo-heading) :: 
		在当前 TODO 事项下面增加一个新的 TODO 事项
   改变 TODO 状态也会触发 tag 改变事件. 细节方面请参见选型'org-todo-state-tags-triggers'的 docstring
** 扩充 TODO 关键字           :工作流和委派
   默认情况下,TODO 事项只有两种状态:TODO 和 DONE. Org-mode 允许你通过设置`TODO 关键字`来对自己的 TODO 事项进行划分.(保存在`org-todo-keywords`中). 不同的文件可用有自己独特的 TODO 关键字设置.
   
   需要注意的是可用通过打 tag 的方式来对标题和 TODO 事项进行区分(参见章节[[#Tags][Tag]])
*** 标示工作流状态的 TODO 关键字    :一步步的从 TODO 状态演化到 DONE 状态
	你可以使用 TODO 关键字来标示事项处于工作流程中的不同状态.例如[fn:45]
	#+BEGIN_SRC elisp
      (setq org-todo-keywords
        '((sequence "TODO" "FEEDBACK" "VERIFY" "|" "DONE" "DELEGATED")))
	#+END_SRC
	这个`|`竖线划分了哪些状态是属于未完结状态,哪些状态是出于已完结状态. 如果你没有提供分隔线,那么最后那个状态被认为是已完结状态. 通过上面这个配置之后,当用命令`C-c C-t`切换状态时,会先从 TODO 切换到 FEEDBACK,然后是 FEEDBACK,最后是 DONE 和 DELEGATED 状态. 你也可以使用数字前缀来快速选择特定的状态,例如`C-3 C-c C--t`会使得状态立即编程 VERIFY. 你也可以使用`S-<left>`来在这个序列中回退状态. 如果你定义了太多的状态,你可以使用 in-buffer 补全(参见[[#Completion][补全]]章节)甚至是单个特定的选择键(参见章节[[#Fast access to TODO states][快速设定 TODO 状态]])来插入特定的 TODO 状态. 你也可用设定当改变 TODO 状态时记录下当时的时间戳数据,更多信息请参见[[#Tracking TODO state changes][跟踪 TODO 状态的改变]]
*** 标示类型的 TODO 关键字          :这件事情我来做,其他的由 Fred 负责
	你还可以使用 TODO 关键字标示事项的不同类型. 例如,你可能向标示有些事情是工作事项,有些事情是生活事项. 或者当你与其他人共同合作一个项目时,你可能想分派任务給某个人,这时你可以直接把那些人的名字当作 TODO 关键字来使用. 配置可能如下所示
	#+BEGIN_SRC elisp
      ,(setq org-todo-keywords '((type "Fred" "Sara" "Lucy" "|" "DONE")))
	#+END_SRC
	这时,这些关键字并不是用来标示工作流程中的不同状态的,它们被用来标示不同的类型. 所以这个时候的工作流程是:先把任务分配給某个人,然后等这件事完成了之后,再标记它为 DONE 状态. 它也支持使用命令`C-c C-t`[fn:46]来切换状态. 若你连续按几次`C-c C-t`的话(经过了一个循环之后),`C-c C-t`会变回去,再不同人物之间切换循环. 而当你中断了连续的`C-c C-t`做了其他操作之后之后,再按`C-c C-t`,该命令又变回从人物直接跳到 DONE 状态了. 同样的,你也可以用前缀参数或补完功能来快速选择特定的人物. 你还可以通过在 sparse tree 中查看某个特定人物的所有代办事项,方法是在`C-c / t`前加前缀的数字参数. 例如,如果你想看分配給 Lucy 的所有事项,你可以用命令`C- C-c / t`来查看. 同样的道理,若你想在一个单独的 buffer 中查看 Lucy 在 agenda 中各 org 文件记录的代办事项,你可以用命令`C- C-c a t`
*** 在一个文件中设置多个关键字     :混用所有关键字
	有时候,你可能想使用平行的多个 TODO 关键字集合. 举个例子来说,你可能向保留有基本的`TODO/DONE`,但是同时需要为 bug 修复定义一套工作流程状态,并且你还需要一个独立的状态表示事项已经被取消了(这是事项的状态不能是 DONE,但是它也没有下一步的行动了). 这时你的配置可能如下
	#+BEGIN_SRC elisp
      (setq org-todo-keywords
            '((sequence "TODO" "|" "DONE")
              (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
              (sequence "|" "CANCELED")))
	#+END_SRC
	各个平行的关键字集合之间的关键字不能出现重复,因为 Org-mode 需要根据该关键字决定该事项是属于哪种流程状态的. 这样子配置之后,`C-c C-t`只会在各个子序列内部循环切换状态,在这个例子中,`DONE`会先切换到`无`再切换到`TODO`,`FIXED`会切换到`无`再切换到`REPORT`. 因此你需要一种方法来让你在最初选择错误的时候可以切换到其他平行的子序列中. 除了直接敲入关键字或者使用补全功能选择关键字之外,你还可以通过以下命令实现这个目的:
	* C-u C-u C-c C-t / C-S-<right> / C-S-<left> ::
	  这些按键会从一个 TODO 子序列跳到下一个 TODO 子序列中,在上一个例子中,`C-u C-u C-c C-t`和`C-S-<right>`会从`TODO`或`DONE`直接跳到`REPORT`状态,然后跳到`CANCELED`状态. 需要注意,这里`C-S-<key>`的键绑定是和`shift-selection-mode[[# Packages that lead to conflicts with Org mode][与 Org-mode 冲突的包]]`冲突的
	* S-<right> / S-<left> :: 
		 这俩命令会遍历所有子序列中的所有关键字,因此 S-<right>会从`TODO`到`DONE`再到`REPORT`. 同样的,它也可能与`shift-selection-mode`有冲突,更多细节参见[[#Packages that lead to conflicts with Org mode][与 Org-mode 冲突的包]]
*** 快速选择 TODO 状态             :通过单个字母快速选择 TODO 状态
    如果你想快速改变事项的状态为某个状态,而不是在各个状态之间遍历,你可以为每个状态指定一个单字母的快捷键. 方法是在每个状态后面加上用括号括住的快捷键.像这样:
    #+BEGIN_SRC elisp
      (setq org-todo-keywords
            '((sequence "TODO(t)" "|" "DONE(d)")
              (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
              (sequence "|" "CANCELED(c)")))
    #+END_SRC
    你键入`C-c C-t`然后输入状态的快捷键就会立即切换到指定的状态了. 如果你想去掉事项上的状态标识,则用`空格`代替快捷键[fn:47]
*** 为各个文件设置独立的关键字     :不同的文件有不同的需求
    很多时候我们需要为不同的文件设置不同的 TODO 关键字. 通过增加一些特殊的行,你可以为每个文件设置自己独有的 TODO 关键字. 例如,你可以在文件的任何一行定格写
    #+BEGIN_SRC org
      ,#+TODO: TODO FEEDBACK VERIFY | DONE CANCELED
      ,#+TYP_TODO: Fred Sara Lucy Mike | DONE
    #+END_SRC
    (你也可以使用`#+SEQ_TODO`,它的意思跟`#+TODO`一样,但是表达更清晰)  
    若需要定义多个平行的子序列,则这样配置:
    #+BEGIN_SRC org
      ,#+TODO: TODO | DONE
      ,#+TODO: REPORT BUG KNOWNCAUSE | FIXED
      ,#+TODO: | CANCELED
    #+END_SRC
      你可以用补全的方式保证输入的关键字无误,方法是输入`#+`然后按下`M-<TAB>`

      请注意,`|`后面的状态关键字(如果没有`|`则最后一个关键字)必须是代表完结状态的关键字(不一定需要 DONE). 在输入完这些以`#+`开头的配置信息后,在配置信息行按下`C-c C-c`使该行的配置信息生效[fn:48]
*** TODO 关键字的显示方式          :高亮状态
    Org-mode 为不同的状态关键字分配了不同的显示方式(emacs 中大概是以 face 这个概念来表示显示方式). 默认情况下对于那些表示还未完结状态的状态关键字使用`org-todo`这个 face,对于那些表示已完结状态的状态关键字使用`org-done`这个 face. 如果你用到了 2 个以上的不同类别的状态,你可以通过配置变量`org-todo-keyword-faces`来为不同的状态关键字分配不同的 face. 举个例子
    #+BEGIN_SRC elisp
      (setq org-todo-keyword-faces
            '(("TODO" . org-warning) ("STARTED" . "yellow")
              ("CANCELED" . (:foreground "blue" :weight bold))))
    #+END_SRC
    像上面例子中`CANCELED`关键字这样直接定义 face 属性列表的方式,有可能不能正确的显示出来. 所以最好还是定义一个 face 然后使用它. 像`STARTED`这样,后面输入的是一个字符串的话,该字符串被解释成是颜色. 而变量`orgfaceseasyproperties`定义了改颜色是前景色还是背景色.      
*** TODO 事项之间的依赖关系        :当一个任务需要等待其他任务的时候
    Org 文件是由层级关系和列表组成的,这样的结构使得定义代办事项之间的依赖关系变得很容易. 通常在所有子任务完成之前是不能把父任务标记为完成状态的. 同时平级任务之间也可能存在一定的逻辑关系,使得后面的任务需要等待前面的任务都完成之后才能完成. 通过定义变量`org-enforce-todo-dependencies`,Org 会阻止父任务在其子任务全部都完结的情况下被标记为完结状态. 此外,如果某个事项定义了`ORDERED`属性,那么它的子任务只有在前面子任务都完成之后才能被标识为已完成状态.下面是一个例子
    #+BEGIN_SRC org
      ,* TODO Blocked until (two) is done
      ,** DONE one
      ,** TODO two
      
      ,* Parent
      ,  :PROPERTIES:
      ,  :ORDERED: t
      ,  :END:
      ,** TODO a
      ,** TODO b, needs to wait for (a)
      ,** TODO c, needs to wait for (a) and (b)
    #+END_SRC
    * C-c C-x o (orgtoggleorderedproperty) ::
      打开/关闭当前事项的`ORDERED`属性. 之所以要用给事项定义属性的方式来声明这种顺次的逻辑关系是因为这种逻辑关系往往只是对某项任务是这样的,它不像 tag 一样具有继承的特性. 当然如果你觉得属性常常被折叠起来不容易看到的话,也可以使用 tag 来跟踪该属性的变化,方法是定义变量`org-track-ordered-property-with-tag`.
    * C-u C-u C-u C-c C-t :: 
	 绕开状态的那些限制,强制更改 TODO 状态
    如果你设置了变量`org-agenda-dim-blocked-tasks`, 那么那些由于依赖关系未满足而无法关闭的代办事项在 agenda 视图中以灰色字体显示甚至是不显示(参见章节[[#Agenda view][Agenda 视图]]).

    你也可以使得这种依赖关系对于 checkbox 也有效(参见章节[[#Checkboxes][checkbox]]).你可以设置变量`org-enforce-todo-checkbox-dependencies`. 然后如果某事项有未勾选掉的 checkbox 的话,也无法切换成完结状态

    如果你需要更复杂的依赖关系(例如在不同的树 n 型结果或文件之间的依赖关系),请使用`org-depend.el`模块
** 记录处理过程             :记录处理过程的时间点和附加信息
   Org-mode 可以在你把代办事项从未完结状态切换到完结状态的时候记录下时间戳和其他一些信息,你甚至可以让它在每次切换状态的时候就记录下这些信息. 这套系统具有很高的可配置性,你可以对某个关键字,或某个文件甚至某个子树范围进行这样的配置. 要了解如何为事项统计所花的工作时间,可以参见章节[[#Clocking work time][统计工作时间]]
*** 结束任务                :你是什么时候结束这项任务的
	能够跟踪某任务什么时候完成是最基本的记录功能. 这项功能可以通过下面这条语句开启[fn:49]
	#+BEGIN_SRC elisp
       (setq org-log-done 'time)
	#+END_SRC
	之后,每次你把一项未完结状态的任务切换到已完结状态的时候,都会在该任务标题下插入一行`CLOSED:[时间戳]`. 如果你把该任务状态又切换回未完结状态,这一行会被删除掉. 如果你希望除了记录时间戳还可以记录一些附加信息,配置[fn:50]
	#+BEGIN_SRC elisp
       (setq org-log-done 'note)
	#+END_SRC
	这样当你把未完结状态的任务切换到已完结状态时,会被提示输入要保存的附加信息,该附加信息会存储在该任务下面,并以`Closing Note`开头
	
	在 timeline(参见章节[[#Timeline for a single file][单个文件的 Timeline]])和 agenda(参见章节[[The weekly/daily agenda][周/日 agenda]])视图中,你可以使用`l`键来显示每日带有'CLOSED'时间戳的代办事项,它会给你一个已完成事项的总括
*** 跟踪任务状态             :什么时候任务状态发生了改变
	有时候你可能想跟踪任务什么时候状态发生了改变,可能还想在状态发生改变的时候记录一些附加信息. 这些信息在插入时会插入到该事项标题的后面作为最新的信息列在第一排[fn:51]. 如果记录的附加信息太长了的话,你可能会希望把这些附加信息放入一个'抽屉'([[#Drawers][drawer]])中. 要实现这一点,需要配置变量`org-log-into-drawer`--推荐使用名为`LOGBOOK`的 drawer. 若你想为某个子树设置其他的 drawer 方式,你可以为这个子树定义`LOG_INTO_DRAWER`属性.

	Org-mode 可以为每个 TODO 关键字定义记录时间戳和附加信息的行为. 你可以在关键字后面用括号括住`!`(表示记录时间戳)或者`@`(表示记录时间戳和附加信息).下面是一个配置的例子
	#+BEGIN_SRC elisp
      (setq org-todo-keywords
        '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
	#+END_SRC
	如果你想对配置了`@`的关键字只记录时间戳,不记录附加信息的话,只需要在提示输入附加信息的时候直接按下`C-c C-c`就行,这会提交一个空白的附加信息

	在上面的例子中,你不仅定义了全局的 TODO 关键字,定义了它们的快捷键,而且你还指定了当事项设置为`DONE`状态的时候,记录下当时的时间戳[fn:52]. 当事项状态改为`WAIT`或`CANCELED`的时候,会提示记录下附加信息. 注意到`WAIT`状态有一个`/!`标志,这表示当离开 WAIT 状态进入到一个不记录任何信息的状态的时候,记录下当时的时间戳. 也就是说,当从`WAIT`切换到`DONE`状态的时候,并不触发记录时间戳的动作,因为 DONE 已经被配置为记录时间戳了. 而当从 WAIT 切换到 TODO 状态的时候,WAIT 状态的`/!`设置会触发记录一个时间戳的动作,因为 TODO 并没有配置任何记录动作

	你也可以把上面的设置限定到一个 buffer 中,方法是在 buffer 某行定格写
	#+BEGIN_SRC org
      ,#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)
	#+END_SRC

	如果只想为某个子树或者某一个事项定义记录动作,你需要为改子树或者事项定义`LOGGING`属性. 如果你定义了非空的`LOGGING`属性,那么原先的记录动作的设置会被清空. 在配置`LOGGING`属性的时候,你可以使用`STARTUP`关键字(例如`lognotedone`或`logrepeat`).也可以明确指定为每个状态指定不同的记录设置(例如`TODO(!)`). 下面是一个例子
	#+BEGIN_SRC org
      ,* TODO Log each state with only a time
      ,  :PROPERTIES:
      ,  :LOGGING: TODO(!) WAIT(!) DONE(!) CANCELED(!)
      ,  :END:
      ,* TODO Only log when switching to WAIT, and when repeating
      ,  :PROPERTIES:
      ,  :LOGGING: WAIT(@) logrepeat
      ,  :END:
      ,* TODO No logging at all
      ,  :PROPERTIES:
      ,  :LOGGING: nil
      ,  :END:
      
	#+END_SRC
*** 跟踪你的习惯             :你能坚持习惯多久
	Org 可以用来追踪习惯的一致性,这里所谓的"习惯"指的是拥有下列特征的待办事项.
	1) 通过配置变量`org-modules`,启用了`habits`模块
	2) 是一个未完成的任务,有一个未完成的状态标示该任务有下一步的行动
	3) `STYLE`属性值设置成了`habit`
	4) 该事项带有规划日期,而且规划日期中可以有`.+时间间隔`用来表示两次重复之间的间隔. `++时间间隔`表示该习惯有时间上的约束(比如,必须在周末完成),`+时间间隔`则表示改习惯不是一个经常性的事项,它可以在之前积压未办之事,然后在未来补完它(比如补写周报)
	5) 改习惯也可以使用类似`.+2d/3d`这样的符号标示最小/最大的间隔时间. `.+2d/3d`的意思是,你希望至少每三条做一次这个工作,但是最多每两天做一次这个工作
	6) 你最好为完结状态设置记录行为,这样会保留一些历史数据,这些历史数据可以以连线图的方式展现出来. 你不是必须要这样做,但是由此产生的连线图的意义就不大了.
	
	为了给你一个直观的感受,下面展示一个带有历史数据的习惯的例子
	#+BEGIN_SRC org
      ,** TODO Shave
      ,   SCHEDULED: <2009-10-17 Sat .+2d/4d>
      ,   - State "DONE"       from "TODO"       [2009-10-15 Thu]
      ,   - State "DONE"       from "TODO"       [2009-10-12 Mon]
      ,   - State "DONE"       from "TODO"       [2009-10-10 Sat]
      ,   - State "DONE"       from "TODO"       [2009-10-04 Sun]
      ,   - State "DONE"       from "TODO"       [2009-10-02 Fri]
      ,   - State "DONE"       from "TODO"       [2009-09-29 Tue]
      ,   - State "DONE"       from "TODO"       [2009-09-25 Fri]
      ,   - State "DONE"       from "TODO"       [2009-09-19 Sat]
      ,   - State "DONE"       from "TODO"       [2009-09-16 Wed]
      ,   - State "DONE"       from "TODO"       [2009-09-12 Sat]
      ,   :PROPERTIES:
      ,   :STYLE:    habit
      ,   :LAST_REPEAT: [2009-10-19 Mon 00:36]
      ,   :END:
	#+END_SRC
	这个例子的意思是:我希望最多每两天,最少每 4 天做一次这个事情(通过`SCHEDULED`日期和重复的时间间隔给定了). 假设今天是 15 号,那么在 agenda 中,该习惯会在 17 号(也就是 2 天之后)的地方显示生效. 在 19 号(也就是 4 天之后)的地方实效

	把习惯用折线图展示出来可以显示在过去你坚持这项习惯的情况如何. 这个折线图显示了过去三个星期每天该习惯的完成情况,每天都根据完成情况用不同的颜色显示出来. 这些颜色有:
	* 蓝色 ::
	  表示当天任务没有完成
	* 绿色 ::
	  表示当天任务已经完成
	* 黄色 ::
	  表示任务在第二天就会过期了
	* 红色 :: 
	  表示工作在当天已经延误了

	另外除了用颜色标注每天的任务完成情况之外,弱于哪些任务在当天已经完成的任务会用星号标注出来. 会用感叹号标注当前日期出来.

	org 提供很多变量来改变 agenda 显示 habit 的方式
	* org-habit-graph-column ::
	  设定统计图从那一列开始画. 由于统计图会覆盖该列上的所有文本,因此最好保持你的 habit 标题简洁明了.
	* org-habit-preceding-days :: 
	     指定从几天前开始统计数据
	* org-habit-following-days ::
	  指示统计到几天之后的数据
	* org-habit-show-habits-only-for-today :: 
	     如果为非 nil 值的话,表示只在当天的 agenda 视图中显示 habits. 默认情况下是设置为 true 的

	最后,在 agenda 视图中按下`k`键会暂时让 habit 隐藏掉. 按'K'之后又会让 habit 显示出来. 它们也受到 tag 过滤的影响,例如你可以设定 habit 只能在某种特定的情况下才能被标记为完成.
** 优先级                   :有些事情更重要一些 
   如果你经常使用 Org-mode 来进行任务安排的话,就应该会发现对各项任务分配优先级是很有必要的,方法是在 TODO 事项的标题前放上优先级标识(` /priority cookie/ `),像这样:
   #+BEGIN_SRC org
     ,*** TODO [#A] Write letter to Sam Fortune
   #+END_SRC
   
   默认情况下,Org-mode 支持从高到低三个优先级,分别表示为`A`,`B`,`C`. 如果某个任务没有分配优先级,则被认为是`B`优先级. 为任务分配优先级的意义仅仅在于在 agenda 视图(参见[[The weekly/daily agenda][周/日 agenda]])中可以依照优先级对任务进行排序. 通过定义变量`org-priority-faces`,你可以为不同的优先级分配不同的显示方式(face)

   优先级标识可以放在任何大纲节点前,而不一定要放在 TODO 事项前
   * C-c , ::
     设置当前任务的优先级(`org-priority`). 执行该命令后,会提示你输入代表优先级的`A` `B` `C`. 如果你输入的是<SPC>则标识去除任务中的优先级标识. 若你在 timeline 或 agenda 视图中时,则可以使用`,`命令来改变优先级.(参见章节[[Commands in the agenda buffer][agenda 视图中的命令]]).
   * S-<up> (org-priority-up) / S-<down> (org-priority-down) :: 
		提升/降低当前任务的优先级[fn:53]. 需要注意的时,这些键也同样可以用来改变时间戳(参见章节[[Creating timestamps][创造时间戳]]). 同样这些按键也可能与`shift-selection-mode`相互冲突,具体情况参见[[ Packages that lead to conflicts with Org mode][与 Org-mode 冲突的包]]

   通过设置变量`org-highest-priority`,`org-lowest-priority`和`org-default-priority`的值,你可以自定义优先级的区间. 若想对某个文件设置优先级区间,你可以像下面那样设置(准照最高优先级,最低优先级,默认优先级的顺序来设置,同时请确保最高优先级在字母表上要比最低优先级靠前)
   #+BEGIN_SRC org
     ,#+PRIORITIES: A C B
   #+END_SRC
** 划分子任务               :划分任务为可管理的碎片
   将一件很复杂的任务分解为简单一些,更易管理的子任务是很有必要的. 你可以在任务事项下面创建新的子树大纲(子任务作为子树的各节点)的方式来表达这种分层关系[fn:54]. 若你想在父任务上显示子任务完成的情况,可以在父任务标题的任何地方插入`[/ ]`或`[% ]`. 每当有子任务被标识为已完结状态之后,这两个标识会被更新为子任务的完成进度,在这两个标识上按下`C-c C-c`也能够强制更新这两个标识的信息.下面是一个例子:
   #+BEGIN_SRC org
     ,* Organize Party [33%]
     ,** TODO Call people [1/2]
     ,*** TODO Peter
     ,*** DONE Sarah
     ,** TODO Buy food
     ,** DONE Talk to neighbor
   #+END_SRC

   如果一个任务标题下面既有 check 列表,也有代办的 TODO 子任务,那么 org 就不清楚应该怎么统计子任务的完成情况了. 这时需要设置属性`COOKIE_DATA`的值为`checkbox`或者`todo`来明确指示统计时以哪个为准

   如果你想在统计子任务完成情况的时候,不是仅仅统计直接下属的子任务的情况,而是统计所有层级的下属子任务,那么你需要配置变量`org-hierarchical-todo-statistics`. 如果你只是对某个特定的父任务有这种需求,那么为该父任务设置`COOKIE_DATA`属性,并且确保该属性的值包含有`recursive`. 下面是一个例子
   #+BEGIN_SRC org
     ,* Parent capturing statistics [2/20]
     ,  :PROPERTIES:
     ,  :COOKIE_DATA: todo recursive
     ,  :END:
   #+END_SRC

   如果你希望父任务在所有子任务都标记为完结状态后,自动也切换到完结状态,你可以用下面所示的配置:
   #+BEGIN_SRC elisp
     (defun org-summary-todo (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
         (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
     
     (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
   #+END_SRC

   当然,你也可以使用 check 列表代替子任务的作用
** checkbox                :标记列表
   如果一个事项是不是以标题的形式而是以纯文本列表[fn:55](参见[[Plain lists][纯文本列表]])的形式展现的,同时它又是以`[ ]`开头的,那么它就被当成是一个代检查事项(checkbox)看待. checkbox 跟待办事项(参见[[TODO iterms][待办事项]])很类似,但是相比起来更加的轻量化.  checkbox 不回显示在全局的未完成事项列表(TODO 列表)中,因此它常常用来表示将一个任务分隔成几个简单的步骤,或者用来作为待购清单来使用. 要切换 checkbox 的状态(完成/未完成状态),需要按下`C-c C-c`,或者使用鼠标点击(多亏了 Piotr Zielinski 的`org-mouse.el`)

   下面是一个 checkbox 列表的例子
   #+BEGIN_SRC org
     ,* TODO Organize party [2/4]
     ,  - [-] call people [1/3]
     ,    - [ ] Peter
     ,    - [X] Sarah
     ,    - [ ] Sam
     ,  - [X] order food
     ,  - [ ] think about what music to play
     ,  - [X] talk to the neighbors
   #+END_SRC
   
   checkbox 具有继承的特性,因此如果一个 checkbox 具有子 checkbox 的话,对子 checkbox 的完成状态进行切换的时候,父 checkbox 也会自动根据是没有/部分/全部子 checkbox 完成状况来做出相应的改变

   在上面例子中,第一行和第二行的`[2/4 ]`和`[1/3 ]`展示了一共有多少个 checkbox,其中多少个 checkbox 一件完成了. 这使得你不用展开就能知道还剩下多少个 checkbox 没有完成. 这种统计信息的展示可以放在标题或者文本列表的任何地方,而且它只会统计直接子任务的完成情况[fn:56]. 为了得到这种统计信息的展示,你需要自己输入`[/ ]`或`[% ]`. 如果你使用的是`[/ ]`,那么你会得到`[n/m]`这样的展示方法(n 表示已完成数,m 表示未完成数). 如果你输入的是`[% ]`,那么你会得到一个百分比的展示. 若在标题的子树下,既有 TODO 事项,又有 checkbox,那么展示的可能为 TODO 事项的统计结果(若触发改变的是由于子 TODO 事项的状态改变而引起的)也可能是 checkbox 的统计结果(若触发改变的结果是由于 checkbox 的状态改变引起的),这样就显得很混乱. 要解决这个问题,设置该标题的`COOKIE_DATA`属性值为`checkbox`或者`todo`即刻

   如果在当前的大纲节点上加了`ORDERED`属性,这就告诉 orgcheckbox 必须从上到下一个一个的被完结, 否则会有报错.

   关于 checkbox 的命令有以下这些:
   * C-c C-c (org-toggle-checkbox) ::
	 切换光标所在 checkbox 的完结状态. 如果加了一个前置参数(也就是用按键`C-u C-c c-c`)则增加/移除 checkbox 标志(使它在 checkbox 和普通列表之间切换)[fn:57], 如果加了两个前置参数(`C-u C-u C-c C-c`)则 checkbox 的标志设为`[-]`,这种标志的意思是其为一种中间状态
   * C-c C-x C-b (org-toggle-checkbox) :: 
		切换光标所在 checkbox 的完结状态. 如果加了两个前置参数(`C-u C-u C-c C-c`)则 checkbox 的标志设为`[-]`,这种标志的意思是其为一种中间状态
	 - 如果存在一个选择域,则切换该选择区域的第一个 checkbox 的完结状态,同时选择区域的其他 checkbox 的完结状态都改为以第一个 checkbox 的完结状态为准. 如果调用该命令时带了一个前置参数(`C-u C-c C-x C-b`)则增加/删除该区域中所有事项的 checkbox 标志
	 - 如果对一个标题进行该操作, 则切换该标题到下一标题间的所有 checkbox 的状态(不是整个子树)
	 - 如果没有选择区域,则切换光标所在的 checkbox 的状态
   * M-s-<RET> (org-insert-todo-heading) ::
	 插入一个新的 checkbox,这只有当光标处于普通列表中时才有效(参见[[Plain lists][普通列表]])
   * C-c C-x o (org-toggle-ordered-property) :: 
		切换是否具有`ORDERED`属性. 如果你希望能够以 tag 的形式来最终`ORDERED`属性的值,你可以设置变量`org-track-ordered-property-with-tag`
   * C-c # (org-update-statistics-cookies) :: 
		更新当前大纲项的统计信息, 若使用了`C-u`前缀,则更新整个文件的统计信息. 当你用`C-c C-c`切换一个 checkbox 的完结状态或者用`M-S-<RET>`新增加一个 checkbox 的时候,会自动更新 checkbox 的统计信息. 同样,当改变 TODO 事项的状态时,也会自动更新 TODO 事项的统计信息. 但是如果你删除 checkbox 和 TODO 事项,或者手工增加/修改 checkbox 和 TODO 事项,那你就需要手工调用这个命令,以强制同步更新统计数据
   * 
* Tags
  每个标题都可以包含多个 tag; 这些 tag 应该放在标题的末尾位置. tag 通常由字母,汉字,数字,-和@组成. tag 的前后必须被冒号包括,像这样`:work:`. 可以同时指定多个 tag,像这样`:work:urgent:`. tag 默认是用跟标题一样的颜色,但是加粗显示. 你也可以为特定的 tag 定义特定的显示方式(face),方法是配置变量`org-tag-faces`, 这跟配置 TODO 关键字的 face 的方法差不多(参见[[Faces for TODO keywords][TODO 关键字的显示方式]])
** Tag 的继承特性            :tag 在大纲中具有继承的特性
   tag 具有继承的特性. 如果一个标题具有某个 tag,那么它的所有子标题自动继承了这个 tag,例如,
   #+BEGIN_SRC org
     ,* Meeting with the French group      :work:
     ,** Summary by Frank                  :boss:notes:
     ,*** TODO Prepare slides for him      :action:
   #+END_SRC
   上例中,最后那一行的标题虽然看起来只有一个 tag,但是其实它有 4 个 tag:`:work:`,`:boss:`,`:notes:`和`:action:`. 你也可以设置文件级的 tag,这样所有该文件的标题,自动继承了这些文件级的 tag. 方法为在文件中加入这样一行[fn:58]
   #+BEGIN_SRC org
     ,#+FILETAGS: :Peter:Boss:Secret:
   #+END_SRC
   
   如果你想只限定某几个 tag 具有继承性,或者根本就不想让 tag 具有继承性,那么你可以通过配置变量`org-use-tag-inheritance`和`org-tags-exclude-from-inheritance`来实现

   如果 tag 的继承特性被打开,那么在作 tag 搜索的时候,若某个父标题匹配了这次搜索,那么它的子树也同样匹配这次搜索[fn:59],这样的话,匹配列表恐怕就会过长. 如果你只想让子树中第一个匹配项可见,请配置变量`org-tags-match-list-sublevels`(我们不推荐这么做)
** 设置 Tag                 :如何为标题分配 tag  
   你可以直接通过在标题后面输入 tag 的方式給标题打 tag. 输入冒号之后,按下`M-<TAB>`,会提供对 tag 的补全. 你也可以用下面的命令来插入 tag
   * C-c C-q (org-set-tags-command) ::
	 为当前标题输入新的 tag. Org-mode 同时也提供补全功能,或給 key 设定单字符的快捷键,具体内容见下文. 在按下<RET>之后,就会插入 tag,并且 tag 自动与`org-tags-column`代表的列对齐. 当调用时带了`C-u`前缀参数时, 当前 buffer 中的所有 tag 都会与该列对齐,这样会显得很工整. 另外,当你对标题进行升级/降级,或者改变 TODO 状态的时候,也会自动对齐 tag 的位置,参见章节[[Basic TODO functionality][最基本的 TODO 功能]]
   * C-c C-c (org-set-tags-command) :: 
		当光标位于标题上时,这个功能与`C-c C-q`一样.
		
   	Org 在插入 tag 时维护了一个 tag 列表. 默认情况下,这个 tag 列表动态的包含了当前 buffer 中的所有 tag. 你也可以通过变量`org-tag-alist`来设置一个全局的固定的 tag 列表. 当然你也可以单独为一个文件设置默认的 tag 列表.
		#+BEGIN_SRC org
          ,#+TAGS: @work @home @tennisclub
          ,#+TAGS: laptop car pc sailboat
		#+END_SRC
	如果你通过变量`org-tag-alist`设置了一个全局的 tag 列表,但是在某些文件中,又希望能够动态获取 tag 列表,你只需要在文件中加入一个空白的 TAG 选项即刻
		#+BEGIN_SRC org
          ,#+TAGS:
		#+END_SRC
	如果你有一些 tag 是每个文件都要用到的,你可以把这些 tag 放入变量`org-tag-persistent-alist`中,这样 org 文件除了具有 TAGS 选项所设定的 tag 外,还具有这个变量所定义的那些 tag. 如果某个文件不想包含该变量所定义的 tag,只需要在 STARTUP 选项行中添加:
		#+BEGIN_SRC org
          ,#+STARTUP: noptag
		#+END_SRC
	默认情况下,Org-mode 在输入 tag 时提供的是标准 minibuffer 补全方式. 然而其实它具有另一个更快捷的 tag 选择方法名叫`快速 tag 选择法(fast tag selection)`. 它可以让你只用一个按键就可以选择/取消一个 tag. 为了让该方法能够很好的工作,你需要为你最常用的 tag 都分配唯一的单独键. 你可以通过在`.emacs`文件中配置变量`org-tag-alist`来实现. 例如你可能在许多文件中都会用到`:@home:`这个 tag,你就可以这样定义
		#+BEGIN_SRC org
          ,(setq org-tag-alist '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))
		#+END_SRC
	如果 tag 只是在当前文件中有效,你可以在文件中设置 TAGS 选项行像这样:
		#+BEGIN_SRC org
          ,#+TAGS: @work(w)  @home(h)  @tennisclub(t)  laptop(l)  pc(p)
		#+END_SRC
	插入 tag 时会在一个新窗口中显示可用的 tag 供你选择. 若你想在某个 tag 之后换行显示,你只需要在它之后插入`\n`即刻:
		#+BEGIN_SRC org
          ,#+TAGS: @work(w)  @home(h)  @tennisclub(t) \n laptop(l)  pc(p)    
		#+END_SRC
	或者你也可用写成两行
		#+BEGIN_SRC org
          ,#+TAGS: @work(w)  @home(h)  @tennisclub(t)
          ,#+TAGS: laptop(l)  pc(p)
		#+END_SRC
	用大括号括起来的 tag,相互之间只能选择一个标识,例如
		#+BEGIN_SRC org
          ,#+TAGS: { @work(w)  @home(h)  @tennisclub(t) }  laptop(l)  pc(p)
		#+END_SRC
	上面的例子说明了,最多只能选择`@work`,`@home`和`@tennisclub`三个之中的一个,作为 tag 标识. 当然多个组之间的 tag 可用放在一起
	当然,别忘了,在这些配置行上按下`C-c C-c`才回使这些改动生效.
	
	若想在设置变量`org-tags-alist`时也表达这种组内相互排斥的 tag,你需要用`:startgroup`和`:endgroup`来代替`{`和`}`. 同样的,你也可用用`:newline`来标识断行. 要把上面哪个例子中的 tag 设置变成全局性的,可用使用如下配置
		#+BEGIN_SRC org
          ,(setq org-tag-alist '((:startgroup . nil)
          ,                      ("@work" . ?w) ("@home" . ?h)
          ,                      ("@tennisclub" . ?t)
          ,                      (:endgroup . nil)
          ,                      ("laptop" . ?l) ("pc" . ?p)))
          
		#+END_SRC
	
	如果至少有一个 tag 分配了快捷键,那么在按下`C-c C-c`之后会显示给你一个特殊的界面,在这里列出了继承到的 tag,当前标题行所明确指定的 tag 和所有其他可用 tag,以及这些 tag 的对应快捷键[fn:60].  在这个界面中,你可以使用如下快捷键:
	 * a-z... ::
	   按下分配給 tag 的快捷键会添加/删除当前行的相应 tag. 如果你选择的 tag 刚好跟其他 tag 处于同一个相互排斥的组,那么其他的 tag 会自动被移除.
	 * <TAB> :: 
				会在 minibuffer 中提示你输入 tag,这个 tag 可用是全新的. 你也可以同时添加多个 tag:只需要用冒号将它们分开就行
	 * <SPC> :: 
				清空当前行的所有 tag
	 * <RET> :: 
				保存当前的 tag 修改
	 * C-g :: 
			  放弃当前的修改
	 * q :: 
			如果`q`没有被分配給 tag 当快捷键,那么它跟`C-g`一样
	 * ! :: 
			关闭相互排斥组的约束,用这个命令可用将相互排斥组的多个 tag 放在一起
	 * C-c :: 
			  开/闭自动退出模式,如果打开自动退出模式,则 org 只接收下一个 tag 的命令,然后就自动退出(见下文). 如果你处于 expert mode 下,那么这个`C-c`会显示 tag 选择窗口(也就是说,在 expert 模式下,C-c C-c 默认也不显示 tag 选择窗口)

	 这些命令使得你可用用很少的按键就可以为标题分配 tag. 举例来说,如果你使用了上面的配置,你可以用`C-c C-c <SPC> h l p <RET>`来清空当前行的 tag,然后为当前行分配‘@home’,‘laptop’和‘pc’标签. 使用`C-c C-c w <RET>`或`C-c C-c C-c w`来将`@home`变成`@work`标签. 通过` C-c C-c <TAB> S a r a h <RET> <RET>`来为当前行分配新标签`sarah`

	 如果你发现你对 tag 的修改大多数时候只需要按一个键就可用完成,这时,你可以设置变量`org-fast-tag-selection-single-key`. 设置之后你不再需要按`<RET>`来退出快速 tag 选择窗口--它会在你做出第一次修改之后立即退出. 如果偶尔你需要作多处修改,你只需要按下`C-c`来取消自动退出模式即可(其实设置了`org-fast-tag-selection-single-key`之后,再按下`C-c C-c`,其效果跟`C-c C-c C-c`一样). 如果你设置该变量的值为`expert`,那么这个 tag 选择窗口甚至不会出现,除非你再按一次`C-c`才会出现
** 搜索 Tag                 :搜索 tag 的组合
   一旦完善的 tag 系统建立起来了,我们就可以利用它将相关联的信息搜集起来
   * C-c / m 或 C-c \ (org-match-sparse-tree) ::
	 将所有匹配 tag 搜索的标题搜集起来放到一个 sparse tree 中. 如果带了`C-u`前缀参,则会忽略哪些不是 TODO 事项的标题
   * C-c a m (org-tags-view) :: 
		从 agenda 文件中搜集所有匹配 tag 搜索的标题. 参见章节[[Matching tags and properties][匹配 tag 和属性]]
   * C-c a M (org-tags-view) :: 
		从 agenda 文件中搜索所有匹配 tag 搜索的标题,但是只搜索 TODO 事项,并且强制进行子树的匹配(参见变量`org-tags-match-list-sublevels`)

   所有这些命令都会提示你输入匹配字符串, 在输入时,允许你使用基本的布尔逻辑,比如`+boss_urgent-project1`的意思是找 tag 中带有`boss`和`urgent`但是没有`project1`的事项. 而`Kathy|Sally`的意思是照 tag 中包含`Kathy`或者`Sally`的事项. 还有其他许多的表达式可以用来匹配 TODO 关键字,事项的层次和属性的. 更多内容请参见[[Matching tags and properties][匹配 tag 和属性]]
* 属性和 column
  属性其实就是一个键值对,它与 org 文件中的条目相关联. 属性可用设置为与 Org 文件中的某个特定条目,或者某棵树下的所有条目,或者整个 buffer 中的条目相关联.

  在 Org-mode 中,属性有两种主要的功能. 第一个功能是类似于带值的 tag. 想象一下你需要维护一个记录 bug 和发布版本的文档. 你可以使用类似`:release_1:`或`release_2`这样的 tag 来标注,或者你可以可用使用一个名叫`:Release:`的属性,但是在不同的子树中给它分配不同的值(比如`1.0`,`2.0`). 第二个功能是使用属性来实现数据库的基本功能. 例如你在记录你的 CD,給它分配的属性可用是`专辑,演唱者,发布日期`等等

  通过 column 视图(参见[[Column view][Column 视图]]),可用很方便的编辑和查看属性
** 属性的语法规则		 		 	 :如何声明属性
   属性是以键值对的形式出现的. 当需要分配属性时,属性需要放入一个名为`PROPERTIES`的特殊抽屉([[Drawers][drawer]])中. 每个属性一行,键(用冒号括起来)在前,值在后. 下面是一个例子
   #+BEGIN_SRC org
     ,* CD collection
     ,** Classic
     ,*** Goldberg Variations
     ,    :PROPERTIES:
     ,    :Title:     Goldberg Variations
     ,    :Composer:  J.S. Bach
     ,    :Artist:    Glen Gould
     ,    :Publisher: Deutsche Grammophon
     ,    :NDisks:    1
     ,    :END:
   #+END_SRC
   根据变量`org-use-property-inheritance`的值的不同,属性可能具有也可能不具有继承性,详见[[Property Inheritance][继承的继承性]]

   你可能想设定属性`:Xyz:`只能有哪些值,你可以通过定义一个名为`:Xyz_ALL`的属性来做到这一点. `:Xyz_ALL:`是一类特殊的属性,该属性具有继承性,因此如果你在第一层条目上设置了这样的属性,它会对整个树生效. 通过约束属性的所有值,可以减少设置属性时输入错误的概率. 举个例子,要记录收集的 CD,你可以预定义好出版人和碟片数量,向下面一样:
   #+BEGIN_SRC org
     ,* CD collection
     ,  :PROPERTIES:
     ,  :NDisks_ALL:  1 2 3 4
     ,  :Publisher_ALL: "Deutsche Grammophon" Philips EMI
     ,  :END:
   #+END_SRC
   如果你向定义在全 file 中都有效的属性,在文件中加入这么一行:
   #+BEGIN_SRC org
     ,#+PROPERTY: NDisks_ALL 1 2 3 4
   #+END_SRC
   如果你想对一个已经存在的属性,添加一个值,只需要在定义时在属性名称后面附上一个`+`号. 例如下面的例子中,属性`var`的值为`foo=1 bar=2`
   #+BEGIN_SRC org
     ,#+PROPERTY: var  foo=1
     ,#+PROPERTY: var+ bar=2
   #+END_SRC
   你不仅可以对定义的属性添加值,还能对继承过来的属性添加值. 下面的例子中,`Goldberg Variations`子树中的`genres`属性的值为`Classic Baroque`
   #+BEGIN_SRC org
     ,* CD collection
     ,** Classic
     ,    :PROPERTIES:
     ,    :GENRES: Classic
     ,    :END:
     ,*** Goldberg Variations
     ,    :PROPERTIES:
     ,    :Title:     Goldberg Variations
     ,    :Composer:  J.S. Bach
     ,    :Artist:    Glen Gould
     ,    :Publisher: Deutsche Grammophon
     ,    :NDisks:    1
     ,    :GENRES+:   Baroque
     ,    :END:
   #+END_SRC

   需要注意的是,每个 Drawer 中的每个属性只能定义一行.
   全局变量`org-global-peroperties`定义的属性被所有的 Org 文件中的所有条目所继承

   下面有一些关于属性的命令
   * M-<TAB> (pcomplete) ::
	 再输入冒号之后按下这个命令键,会列出当前文件可用所有属性名,可用直接用鼠标点击要加入的属性名即可
   * C-c C-x p (org-set-property) :: 
		设置属性. 这个命令会提示你输入要编辑的属性名称和属性值. 如果输入的新的属性名,则会新增该属性
   * S-<right> (org-peroperty-next-allowed-value) 或 S-<left> (org-peroperty-previous-allowed-value) :: 
		将光标所在的属性切换到上一个/下一个可选值
   * C-c C-c (org-peroperty-action) :: 
		在属性抽屉中按下这个命令键,会显示出各种操作属性的命令,可进行设置属性,删除属性,全局删除属性,计算属性值等操作. 具体说明见下文
   * C-c C-c s (org-set-peroperty) :: 
		设置当前抽屉中的的任选某个属性. 属性名和属性值都可以以计算的方式插入
   * C-c C-c d (org-delete-peroperty) :: 
		删除当前抽屉中的某个属性
   * C-c C-c D (org-delete-property-globally) :: 
		全局删除某个属性,对当前文件中的所有条目都生效
   * C-c C-c c (org-compute-peroperty-at-point) :: 
		计算光标所在的属性, 
** 特殊的属性		 		 		 :Org-mode 的其他特性说明
   一些特定的属性被定义用来开启 Org-mode 的一些特性(比如前面章节中讲到的 TODO 状态和优先级). 之所以提供这些特殊的属性,是为了让你可以在 column 视图中查看到这些状态,还可以在搜索时匹配这些状态. 下面列出的这些特殊属性名,这些属性(除了`:CATEGORY:`)不应该放入属性抽屉中中
   #+BEGIN_EXAMPLE
     TODO         The TODO keyword of the entry.
     TAGS         The tags defined directly in the headline.
     ALLTAGS      All tags, including inherited ones.
     CATEGORY     The category of an entry.
     PRIORITY     The priority of the entry, a string with a single letter.
     DEADLINE     The deadline time string, without the angular brackets.
     SCHEDULED    The scheduling timestamp, without the angular brackets.
     CLOSED       When was this entry closed?
     TIMESTAMP    The first keyword-less timestamp in the entry.
     TIMESTAMP_IA The first inactive timestamp in the entry.
     CLOCKSUM     The sum of CLOCK intervals in the subtree.  org-clock-sum
                  must be run first to compute the values in the current buffer.
     BLOCKED      "t" if task is currently blocked by children or siblings
     ITEM         The content of the entry.
     FILE         The filename the entry is located in.
     
   #+END_EXAMPLE
** 搜索属性		   		   		     :匹配属性值
   属性搜索的命令和 tag 搜索(参见章节[[Tag searches][tag 搜索]])的命令一样的
   * C-c / m 或 C-c \ (org-match-sparse-tree) ::
	 将所有匹配 tag 搜索的标题搜集起来放到一个 sparse tree 中. 如果带了`C-u`前缀参,则会忽略哪些不是 TODO 事项的标题
   * C-c a m (org-tags-view) :: 
		从 agenda 文件中搜集所有匹配 tag/属性搜索的标题. 参见章节[[Matching tags and properties][匹配 tag 和属性]]
   * C-c a M (org-tags-view) :: 
		从 agenda 文件中搜索所有匹配 tag 搜索的标题,但是只搜索 TODO 事项,并且强制进行子树的匹配(参见变量`org-tags-match-list-sublevels`)
   关于搜索串的语法参见[[Matching%20tags%20and%20properties][匹配 tag 和属性]]

   还有一个搜索单个属性的命令:
   * C-c / p
	 该命令根据属性值进行搜索匹配. 它首先提示你输入要搜索的属性名,然后是要匹配的值. 然后就会查找出所有拥有该属性并且属性值为指定值的条目. 在输入待匹配的属性值时,用`{}`括起来的值被当作是正则表达式处理.
** 属性继承		   		   		     :下级继承上级的属性值
   属性可以具有继承性.但是默认情况下,Org-mode 不打开该特性,因为它会极大地拖慢属性搜索的速度并且实用性也不大. 然而如果你觉得很有必要打开它的继承性,你可以通过设置`org-use-property-inheritance`来实现. `org-use-property-inheritance`的值为`t`表示开启继承性,为`nil`表示关闭继承性

   Org-mode 中也有一些属性是强制具有继承性的.
   * COLUMNS ::
	 `:COLUMNS:`属性定义了 column 视图的格式(参见章节[[Column view][Column 视图]]). 它的继承性的意义为:定义了`:COLUMNS:`属性的层次被认为是 column 视图表格的开始部分.它与子树中 column 视图被开启的位置相互独立(independently of the location in the subtree from where columns view is turned on. )
   * CATEGORY :: 
				 在 agenda 视图中显示时,通过`:CATEGORY:`属性设置的类别对整个子树都有效
   * ARCHIVE :: 
				在归档时有用,`:ARCHIVE:`属性定义了整个子树中的归档位置(参见章节[[Moving a tree to the archive file][移动树到归档文件中]])
   * LOGGING :: 
				`:LOGGING:`属性为条目或子树定义了记录日志的设置情况(参见章节[[Tracking TODO state changes][追踪 TODO 状态的改变]])
** Column 视图		 		 		 :以表格的方式浏览与编辑
   要查看和编辑一个大纲树中的属性,有一个很好的方法,那就是 column 视图. 在 column 视图中,每个大纲节点都被转换为表格中的一行. 各条目的属性就是表格中的列. Org-mode 并不实际修改 buffer,而只是通过在标题上多现实出一个表格结构体的方式实现 column 视图的. 因此,即使标题被转换成了表格的行了,但是你依然可以切换大纲树的可视性. 例如,你通过切换到目录(CONTENTS)视图模式(通过`S-<TAB> S-<TAB>`切换,若在 column 视图中,则直接按`c`即可),得到一个紧凑的概况表格. 这时,你依然可以打开,阅读和编辑每个标题下面的各个条目. 你也可以在执行 sparse 树命令之后再切换到 column 视图,通过这种方式,你可以在表格中只现在筛选出来的内容. 你也可以在[[Agenda views][agengda]]视图中切换成 Column 显示方法,这样你可以在表格中同时显示多个文件中的筛选内容.
*** 定义列		  		  		     :COLUMNS 格式属性
	要想使用 column 视图,先得定义列. 这是通过定义列格式行(column format line)的方式来进行的
**** 列定义的范围		 		     :在哪里定义?作用的范围有哪些
	 要定义整个文件范围的列格式,使用类似下面的行
	 #+BEGIN_SRC org
       ,#+COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
	 #+END_SRC

	 如果只想对某颗树的范围内定义列格式,对这棵树的最顶层节点添加`:COLUMNS:`属性,例如
	 #+BEGIN_SRC org
       ,** Top node for columns view
       ,   :PROPERTIES:
       ,   :COLUMNS: %25ITEM %TAGS %PRIORITY %TODO
       ,   :END:
	 #+END_SRC

	 `:COLUMNS:`属性具有继承性,因此你可以在上层为各子层定义足够普遍的格式定义,然后在编辑更深层次时定义更特化的格式定义
**** 列属性		   		   		     :列的内容和展示
	 column 的定义式中可以包含有列的属性. 一般来说列的定义式看起来是这样做的
	 #+BEGIN_SRC org
       ,%[width]property[(title)][{summary-type}]
	 #+END_SRC
	 除了百分号和属性名之外,所有的都是可选的. 各部分的意思如下所示
	 #+BEGIN_EXAMPLE
       width           整型,代表了列的宽度,如果忽略则由 org 自动决定
                       
       property        该列所表示的属性,可以是上文提到的哪些特殊属性
                       
       title           列的标题,如果忽略,则会使用属性名代替
                       
       {summary-type}  总和的类型,如果指定了,那么父节点的列值由其下子节点的值计算得到
                       支持的总和类型包括:
                       {+}       Sum numbers in this column.
                       {+;%.1f}  Like ‘+’, but format result with ‘%.1f’.
                       {$}       Currency, short for ‘+;%.2f’.
                       {:}       Sum times, HH:MM, plain numbers are hours.
                       {X}       Checkbox status, ‘[X]’ if all children are ‘[X]’.
                       {X/}      Checkbox status, ‘[n/m]’.
                       {X%}      Checkbox status, ‘[n%]’.
                       {min}     Smallest number in column.
                       {max}     Largest number.
                       {mean}    Arithmetic mean of numbers.
                       {:min}    Smallest time value in column.
                       {:max}    Largest time value.
                       {:mean}   Arithmetic mean of time values.
                       {@min}    Minimum age (in days/hours/mins/seconds).
                       {@max}    Maximum age (in days/hours/mins/seconds).
                       {@mean}   Arithmetic mean of ages (in days/hours/mins/seconds).
                       {est+}    区间的总和
       
	 #+END_EXAMPLE
	 需要注意的是,一个属性只能有一种总和类型. 低层列当涉及到相同的属性时,会显示一样的总和信息.

	 `est+`这种总和类型需要多做一些说明. 它常常用来合计那些范围数据. 例如你在评估一项任务的时候可能不会说就是 5 天搞定,相反你可能会说大概 5-6 天的时候能搞定,甚至如果你对这个任务一无所知的化可能估计要 1-10 天才能搞定. 这两种区间平均来说都是 5.5 天搞定,但是第一种表达明显更精确一点.
	 
	 当在计算这种区间的的总和时,一般的做法是把各区间的最低值和最高值相加形成一个区间,然而这个区间往往跨度太大而没什么用. `est+`则不采用这种计算方法. 它会计算各区间的平均值和方差,并根据总和生成一个最终估计. 举个例子, 假设你有 10 项任务,每项任务估计都要话 0.5-2 天才能昨晚. 如果采用一般的方法直接累计的结果是完成这 10 项任务需要花 5-20 天的时间. 然而如果使用`est+`这种计算方式则估计出值为 10-15 天,这个值明显更真实一些.

	 下面是一个完整的列定义的例子.[fn:61]
	 #+BEGIN_SRC org   
       ,:COLUMNS:  %25ITEM %9Approved(Approved?){X} %Owner %11Status %10Time_Estimate{:} %CLOCKSUM
       ,:Owner_ALL:    Tammy Mark Karl Lisa Don
       ,:Status_ALL:   "In progress" "Not started yet" "Finished" ""
       ,:Approved_ALL: "[ ]" "[X]"
	 #+END_SRC
	 第一列`%25ITEM`的意思是取条目(例如标题)的前 25 个字节为内容. 基本上你在定义列定义时都应该以`ITEM 列`开头. 其他的列定义部分则定义了一个名为`Owner`的列,该列限定了几个可选值. 定义了一个名为`Status`的列并定义了 4 个可选值, 还有放置 checkbox 的列`Approved`. 若`%`之后没有定义列宽,则列宽会刚好足够显示所有的值. `Approved`列有一个被修改过的标题(`Approved?`,这里有个问号). 对于列`Time_Estimate`会自动累计时间段,格式为`HH:MM`, 而对于列`Approved`来说,如果所有的子节点都 check 过了,则会显示一个`[X]`表示完结状态. `CLOCKSUM`列比较特殊,它列出子树中的 CLOCK 间隔时间的总和
*** 使用 column 视图		  		     :如何创建和使用 column 视图
	+ 开/关 column 视图
	  * C-c C-x C-c (org-columns) ::
		打开 column 视图模式. 如果执行命令时光标在文件第一个标题上面,那么整个文件都会开启 column 视图模式,column 视图现实时是参照`#+COLUMNS`的定义来现实的. 如果光标是在大纲内部的化,命令会从改点开始往下搜索所有子树,查找`:COLUMNS:`属性. 当找到一个`:COLUMNS:`属性后,会为以带有该属性的条目为起点的子树建立 column 视图表格. 如果没有找到`:COLUMNS:`属性,那么会以光标所在条目为起点的子树建立 column 视图,其参照的格式为`#+COLUMNS`行或变量`org-columns-default-format`中的定义
	  * r (org-columns-redo) :: 
		   刷新 column 视图,让它反应最近的修改
	  * g (org-columns-redo) :: 
		   跟`r`一样
	  * q (org-columns-quit) :: 
		   退出 column 视图
	+ 编辑值
	  * <left> <right> <up> <down> ::
		在 column 视图中的域之间跳转
	  * S-<left> /S-<right>  :: 
		   切换域中的值为下一个/上一个可能的值,因此你必须要为该属性定义好可选的值
	  * 1...9,0 :: 
				   直接选择第 N 个可选值,0 表示选择第 10 个可选值
	  * n (org-columns-next-allowed-value) /p (org-columns-previous-allowed-value) :: 
		   跟 S-<left> /S-<right>一样
	  * e (org-columns-edit-value) :: 
		   编辑光标所在的属性值.
	  * C-c C-c (org-columns-set-tags-or-toggle) :: 
		   当光标处于 checkbox 处时,切换它的勾选状态
	  * v (org-columns-show-value) :: 
		   查看属性的完整值,这在当列宽度比值宽度要小的时候很有用
	  * a (org-columns-edit-allowed) :: 
		   编辑该属性的可选值. 如果之前就已经设定了可选值,那么修改过的值就存储在之前设定可选值的位置.否则的话新的可选值会记录在当前 column 视图的第一个条目处.
	+ 修改表 column 视图格结构
	  * < (org-columns-narrow) / > (org-columns-widen) ::
		缩小/放大列的宽度
	  * S-M-<right> (org-columns-new) ::
		在当前列的左边插入一行新列
	  * S-M-<left> (org-columns-delete) :: 
		   删除当前列
*** 捕捉 column 视图		  		     :column 视图的动态区块
	由于 column 视图并不正真修改 buffer,它只是一种显示方式而已,因此它不能直接被导出或者被打印出来. 如果你需要捕获 column 视图的内容,你需要定义`columnview`动态区块(dynamic block). 这种动态区块的框架类似于这样的:
	#+BEGIN_SRC org
      ,* The column view
      ,#+BEGIN: columnview :hlines 1 :id "label"
      
      ,#+END:
      
	#+END_SRC
	
	定义动态区块时可以使用以下这些参数:
	* :id ::
	  这是最重要的参数. 因为动态区块所处的位置跟要捕获的 column 视图的位置很可能不一致,这就要求用一种方法来定义那部分的 column 视图需要被捕获. 这个参数有 4 个值
	  #+BEGIN_EXAMPLE
        local     use the tree in which the capture block is located
        global    make a global view, including all headings in the file
        "file:path-to-file"
                  run column view at the top of this file
        "ID"      call column view in the tree that has an :ID:
                  property with the value label.  You can use
                  M-x org-id-copy to create a globally unique ID for
                  the current entry and copy it to the kill-ring.
	  #+END_EXAMPLE
	* :hlines :: 
				 如果为`t`,则表示每一行后面都插入一条横线. 若设置为数字 N,则表示对于所有层级<=N 的标题,在标题前插入一条横线
	* vlines :: 
				若设置为`t`,则表示强制用竖线分隔各属性列
	* :maxlevel :: 
				   若设置为数字 N,表示不捕捉层级在 N 级以下的条目
	* :skip-empty-rows :: 
		 若设置为`t`,则会跳过那些除了`ITEM`属性列外,其他属性列都是空值的行

	下面还有一些命令是用来插入或更新动态区块(dynamic block)的
	* C-c C-x i (org-insert-columns-dblock) ::
	  插入一个 dynamic block,你需要输入要捕获的 column 视图的范围或 ID
	* C-c C-c / C-c C-x C-u (org-dblock-update) :: 
		 更新光标所在的 dynamic block. 光标的位置需要在 dynamic block 的`#+BEGIN`这一行
	* C-u C-c C-x C-u (org-update-all-dblocks) :: 
		 更新所有的 dynamic blocks. 当你在一个 buffer 中有多个 dynamic block 时很有用

	你可以在 column 视图表格中插入公式并且你可以在表格前插入绘图说明--这些操作会随着 block 的更新而一起更新. 如果表格后面有用`#+TBLFM:`定义计算公式,那么这些公式也会随着 block 的更新而重新计算

	另一个捕获和处理属性值的方法是使用 Eric Schulte 的`org-collector.el`,这是一个第三方包[fn:62]. 它提供了大量的 API 来获得某个条目或者某个范围的属性. 并且可以使用任意的 Lisp 表达式来处理这些属性值然后再插入到表格或者动态区块(dynamic block)中去
** 属性 API		  		  		  	 :提供給 Lisp 程序员的属性相关的 API
   有大量的 API 提供来获取和修改属性. Emacs Lisp 程序员可以使用这些 API 来编辑属性或实现与这些属性相关的特性. 更多信息参见[[ Using the property API][使用属性 API]].
* 日期与时间
  为了协助进行项目计划. TODO 事项可以加上日期和时间的标签. 这种带有日期和时间信息的特定字符串在 Org-mode 中被称呼为时间戳(timestamp). 这可能会让人有点迷糊,因为时间戳常常用来标识事情是什么时候创建或改变的. 然而,在 Org-mode 中,该名称的意义更加广泛
** 时间戳,最后期限和规划日期				:給事项分配时间
   时间戳以一种特定的格式来标识日期(也可能是时间或一个时间段),比如想这样:`"< 2003-09-16 Tue >"[fn:63] ,`< 2003-09-16 Tue09:39 >`,`‘< 2003-09-16 Tue 12:00-12:30 >`[fn:64]. 时间戳可以放在标题和条目的任意位置处. 带有时间戳的条目在 agenda 视图中会显示在特定的日期区域(参见[[The weekly/daily agenda][周/日 agenda]]). 时间戳有以下几种格式:
   * 单纯的一个时间点,一般用于单次的约会,会议等
	 时间戳最基本的作用就是为某事项分配一个日期/时间. 这就好像在日程表中安排一项日程一样. 当用 timeline 或 agenda 视图查看安排时,带有时间戳的事项就会出现在时间戳指示的日期处.
	 #+BEGIN_SRC org
       ,* Meet Peter at the movies <2006-11-01 Wed 19:15>
       ,* Discussion on climate change <2006-11-02 Thu 20:00-22:00>
	 #+END_SRC
   * 带有重复间隔的时间戳
	 如果你想标识某件事不仅仅是在指定的那天需要去办,而且在之后的时间里,每隔 N 天(d),周(w),月(m)或年(y)也需要重复的做这件事情. 这时你可以在时间戳中包含重复间隔的信息. 例如下面的例子说明了每周周三都要去作的事情
	 #+BEGIN_SRC org
       ,* Pick up Sam at school <2007-05-16 Wed 12:30 +1w>
	 #+END_SRC
   * diary 风格的类 lisp 表达式(Diary-style sexp entries)
	 要表达更复杂的时间需求, Org-mode 可以使用 diary 风格的类 lisp 表达式来表示时间,这种表达式是由 Emacs 内置的 calendar/diary 包实现的.[fn:65]. 下面是一个例子
	 #+BEGIN_SRC org
       ,* 22:00-23:00 The nerd meeting on every 2nd Thursday of the month
       ,  <%%(org-float t 4 2)>
	 #+END_SRC
   * 时间段
	 用`--`连接起来的两个时间戳就表示一个时间段. 下面是一个例子
	 #+BEGIN_SRC org
       ,** Meeting in Amsterdam
       ,   <2004-08-23 Mon>--<2004-08-26 Thu>
	 #+END_SRC
   * 无效的时间戳
	 跟一般的时间戳差不多,只是用方括号代替尖括号. 这种时间戳不会影响事项在 agenda 中的显示
	 #+BEGIN_SRC org
       ,* Gillian comes late for the fifth time [2006-11-01 Wed]
	 #+END_SRC
** 创建时间戳		 		 		    :插入时间戳的命令
   Org-mode 中的时间戳必须是复合特定的格式的. 因此 Org 提供了下面这些命令生成正确格式的时间戳
   * C-c . (org-time-stamp) ::
	 该命令提示你输入日期然后插入对应的时间戳. 如果执行该命令时,光标已经处于时间戳上,则该命令修改时间戳,而不是插入新的时间戳. 如果连续两次成果执行该命令,则插入的是一个时间段.
   * C-c ! (org-time-stamp-inactive) :: 
		类似于 C-c . 但是插入的是一个无效的(inactive)时间戳,这种时间戳不会影响事项在 agenda 上的显示
   * C-u C-c . /C-u C-c ! :: 
	类似`C-c .`和`C-c !`,但是包含日期和时间. 默认的时间会自动四舍五入到每 5 分钟为单位.参见选项`org-time-stamp-rounding-minutes`
   * C-c C-c  :: 
				 更正时间戳,如果星期数错了或者没有,就会修正或者插入正确的星期数
   * C-c < (org-date-from-calendar) :: 
		插入 Calendar 窗口中光标所处的日期所对应的时间戳
   * C-c > (org-goto-calendar) :: 
		打开 Emacs Calendar 窗口并定为到今天. 若光标处于时间戳处,则定为到时间戳表示的位置
   * C-c C-o (org-open-at-point) :: 
		在 agenda 窗口中打开时间戳所指定的日期或时间段(参见章节[[ The weekly/daily agenda][周/日 agenda]])
   * S-<left> (org-timestamp-down-day) / S-<right> (org-timestamp-up-day) ::
	 减少/增加光标所在的日期一天. 这些按键序列与 shift-selecton 及相关模式相互冲突(参见章节[[ Packages that lead to conflicts with Org mode][与 org-mode 冲突的包]])
   * S-<up> (org-timestamp-up) / S-<down> (org-timestamp-down) :: 
		更改光标所处的时间戳中的各个部分(年,月,日,时,分). 若时间戳是一个类似‘15:30-16:30’的时间段,则修改第一个时间也会同时改变第二个时间,为的是保持时间跨度不变. 若想修改时间跨度,请直接修改第二个时间. 需要注意的是,若光标不是处于时间戳中,而是处于标题上,则该键序列会修改事项的优先级(参见章节[[Priorities][优先级]]).这些按键序列与 shift-selecton 及相关模式相互冲突(参见章节[[ Packages that lead to conflicts with Org mode][与 org-mode 冲突的包]])
   * C-c C-y (org-evaluate-time-range) :: 
		根据时间段计算出时间跨度显示在 minibuffer 上. 如果带有前缀参数,则将结果写道时间段的后面(若是在表格中,则写到下一列的位置)
*** 日期/时间的提示窗口		   		    :Org-mode 是如何帮助你输入日期和时间的
	当 Org-mode 提示输入日期/时间时,会有一个默认值,这个默认值是以缺省的格式来显示的,这给人的感觉似乎只能输入这种特定的格式的时间才行. 其实 Org-mode 可用处理任何包含有日期/时间信息的字符串,并且很智能的提取出其中的日期/时间信息. 例如你可以使用`C-y`粘贴 email 中的内容(可能有多行). Org-mode 会丢弃任何不符合默认日期/时间格式的字符串,从而提取出其中的日期/时间信息. 提示的默认值一般来说是当前日期,但是如果是在修改一个已经存在的时间戳或者输入时间段的第二个时间戳信息时,默认值使用的是 buffer 中的哪个时间戳信息. 当输入日期信息时, Org-mode 假设大多数时候你想要输入的都是未来的日期,因此如果你没有输入月/年,同时你输入的天/月又比今天要早时,Org-mode 会基于"你输入的是未来的日期"这个假设自动填充月/年信息[fn:66]. 如果输入的日期被自动调整到未来的日期,时间提示符会出现`(=>F)`以此来提醒你

	举个例子,假设今天是 2006 年 6 月 13 日. 下面列出一些输入和实际解释的对应关系
	#+BEGIN_EXAMPLE
      3-2-5         ⇒ 2003-02-05
      2/5/3         ⇒ 2003-02-05
      14            ⇒ 2006-06-14
      12            ⇒ 2006-07-12
      2/5           ⇒ 2007-02-05
      Fri           ⇒ nearest Friday (default date or later)
      sep 15        ⇒ 2006-09-15
      feb 15        ⇒ 2007-02-15
      sep 12 9      ⇒ 2009-09-12
      12:45         ⇒ 2006-06-13 12:45
      22 sept 0:34  ⇒ 2006-09-22 0:34
      w4            ⇒ ISO week for of the current year 2006
      2012 w4 fri   ⇒ Friday of ISO week 4 in 2012
      2012-w04-5    ⇒ Same as above
	#+END_EXAMPLE

	另外,你还可以输入相对日期,格式是第一个字符用加减号开头,随后是一个用来表示时间长度的数字和一个用来表示天(d)/周(w)/月(m)/年(y)这种时间单位的字符. 如果以一个`+/-`开头,则表示日期是相对于今天来说的. 如果是以两个`+/-`开头,则表示是相对于默认日期来说的. 如果你省略了表示时间单位的哪个字符,则默认为天. 下面是一些例子
	#+BEGIN_EXAMPLE
      +0            ⇒ today
      .             ⇒ today
      +4d           ⇒ four days from today
      +4            ⇒ same as above
      +2w           ⇒ two weeks from today
      ++5           ⇒ five days from default date
      +2tue         ⇒ second Tuesday from now.
	#+END_EXAMPLE

	时间函数能够理解英文中的月份了星期几的缩写形式. 如果你像是用英文全称或其他语言,请配置变量`parse-time-months`和`parse-times-weekdays`

	由于当前的 Emacs 实现并不能合理的表示所有的日期,因此默认情况下 Org-mode 强制日期的合理区间为 1970 年-2037 年,因为这区间的时间对于所有的 Emacs 实现都是可处理的. 如果你想使用超过这个时间段的日期,请先阅读变量`org-read-date-force-complatible-dates`的文档字符串

	定义一个时间段有两种方式,一中方式是用一个或两个`-`将开始和结束时间连接起来. 另一种是用`+`将开始时间与时间段长度连接起来. 举例子如下
	#+BEGIN_EXAMPLE
      11am-1:15pm    ⇒ 11:00-13:15
      11am--1:15pm   ⇒ same as above
      11am+2:15      ⇒ same as above
	#+END_EXAMPLE

	除了 minibuffer 中的提示符,Org-mode 也可能会弹出一个 calendar 窗口让你选择日期[fn:67]. 在 calendar 窗口中,你可以通过单击日期或直接安回车的方式选择日期,随后该日期会插入到提示符中去. 你可以在光标不离开 minibuffer 的同时控制 calendar. 命令如下:
	#+BEGIN_EXAMPLE
      <RET>           Choose date at cursor in calendar.
      mouse-1        Select date by clicking on it.
      S-<right>/<left>     One day forward/backward.
      S-<down>/<up>     One week forward/backward.
      M-S-<right>/<left>   One month forward/backward.
      > / <          Scroll calendar forward/backward by one month.
      M-v / C-v      Scroll calendar forward/backward by 3 months.
	#+END_EXAMPLE

	日期/时间提示符的这些操作看起来很复杂,但是你很快就能适应它们, 随后你会觉得使用其他方式输入日期/时间很不方便. 为了帮助你理解你输入的到底是什么日期,对你输入的实时解释会显示在 minibuffer 中[fn:68]
*** 定制时间格式							:让时间看起来与众不同
	Org-mode 使用 ISO8601 的日期和时间规范. 如果你不习惯此规范想换成其他格式的显示方式,你需要配置变量`org-display-custom-times`和`org-time-stamp-custom-formats`
	* C-c C-x C-t (org-toggle-time-stamp-overlays)
	  切换客户化定制的日期/时间显示的格式
	
	在输入时间/日期时,Org-mode 还是修安排使用默认的格式. 实际上,客户化定制的时间格式并不会正在改变文件中的实际时间格式(存入文件的还是以默认格式存入的). 它只是在显示时转换成客户化定制的格式显示而已. 因此就会造成下面这些后果
	* 你不能把光标移动到时间戳内部了,你只能从时间戳前面直接跳到时间戳的后面
	* `S-<up>`,`S-<down>`不能再用于调整时间戳的内部组件了. 如果光标在时间戳前面,则`S-<up>/<down>`跟`S-<left>/<right>`一样,增减一天. 如果光标在时间戳后面,则时间戳增减一分钟
	* 如果时间段或包含了重复间隔信息的时间戳是不会被转换显示的,还是保留原样
	* 若在表格中包含了日期,则若定制的时间格式比原格式长,表格的对齐会被搞乱,如果比原格式短,则可用正常对齐
** 最后期限和规划日期		 		 		:制定工作计划
   * 最后期限(DEADLINE)
	 当到达最后期限时,该任务会显示在 agenda 中. 另外在 today 这个 agenda 上也会警示一些快要(由变量 org-deadline-warning-days 决定提前多少天开始警告)或者已经逾期的任务,该警示会一直持续到任务标识为完成后才消失. DEADLINE 的一个例子如下:
	 #+begin_src org
       *** TODO write article about the Earth for the Guide
       DEADLINE: <2004-02-29 Sun>
       The editor in charge is [[bbdb:Ford Prefect]]
	 #+end_src
	 你可以在设置 DEADLINE 的同时设置提前多少天发出警示,例如下面的例子表示提前 5 天发出警示
	 #+begin_src org
       DEADLINE: <2004-02-29 Sun -5d>    
	 #+end_src
   * 规划日期(SCHEDULED)
	 当到达规划日期及之后,该任务会在 agenda 中一直显示[fn:69]. 另外在 today 这个 agenda 上会显示今天距离规划日期已经过去多少天了. 该显示会一直持续到任务被标记为完成状态为止. 下面是一个例子
	 #+begin_src org
       *** TODO Call Trillian for a date on New Years Eve.
           SCHEDULED: <2004-12-25 Sat>
	 #+end_src
*** 插入最后期限和规划日期
	下面的命令使你可以快速插入[fn:70]最后期限和规划日期
	* C-c C-d (org-deadline)
	  在标题的下一行插入 DEADLINE 关键字,该关键字用来标识最后期限信息. 除了插入 DEADLINE 关键字外,任何 CLOSED 时间戳都会被删除调.
	  若调用该命令时带了前缀参数,则表示删除 DEADLINE 关键字. 
	  根据变量`org-log-redeadline`[fn:71]的值,当更改已经存在的最终期限时,可能会记录日志
	* C-c C-s (org-schedule)
	  在标题的下一行插入 SCHEDULED 关键字,该关键字标识了规划日期的信息. 除了插入 SCHEDULED 关键字外,任何 CLOSED 时间戳都会被删除.
	  若调用该命令时带了前缀参数,则标识删除 SCHEDULED 关键字.
	  根据变量`org-log-reschedule`[fn:72]的值,当更改已经存在的规划日期时,可能会记录日志
	* C-c C-x C-k (org-mark-entry-for-agenda-action)
	  标记当前任务为 agenda action 的目标. 执行该命令后,可以打开 agenda 或 calenda,把光标定位到何时的日期处,然后按下 k 键,会有一系列的 agenda action 提供来选择.
	* C-c / d (org-check-deadlines)
	  创建一颗 sparse tree,在该 sparse tree 中包含了哪些已经超期或者快要超期(根据变量 org-deadline-warning-days 决定)的任务.
	  若带有 C-u 前缀,则显示当前文件中的所有带有 deadline 的条目.
	  若带有数字前缀 N,则显示 N 天内超期的和已经超期的条目,例如`C－1 C-c / d`显示所有明天就会超期的条目.
	* C-c / b (org-check-before-date)
	  创建一颗 sparse tree,在该 sparse tree 中包含了那些最终期限或规划日期在给定日期之前的条目
	* C-c / a (org-check-after-date)
	  创建一颗 sparse tree,在该 sparse tree 中包含了那些最终期限或规划日期在给定日期之前的条目
	
	注意:org-shedule 和 org-deadline 支持通过指定相对时间来标识日期,例如+1d 意思是当前时间戳的下一天,-1w 意思是当前时间戳的上一个星期
*** 重复的任务
	有些任务是重复性的. Org mode 通过在 DEADLINE,SCHEDULED 或普通的时间戳中放置所谓的`repeater`来标识这种重复性的任务. 例如
	#+begin_src org
      , ** TODO Pay the rent
      ,   DEADLINE: <2005-10-01 Sat +1m>
	#+end_src
	这里的+1m 就是 repeater. 意思是每个月重复一次. 如果你需要在一个 DEADLINE 中同时表明 repeater 和指定预警期的话,则 repeater 需要放在前面,预警期放在后面,例如
	#+begin_src org
      ,DEADLINE: <2005-10-01 Sat +1m -3d>. 
	#+end_src
	
	当任务的最后期限和规划时间超期后,就会在 agenda 中出现. 因此即使标记带有 DEADLINE 和 SCHEDULE 的任务为 DONE 状态就很重要了. 当你将这种任务标记为 DONE 状态后,该任务就不会在 agenda 中出现了. 
	然而这么作带来一个问题,带有 repeater 的任务被标识为 DONE 之后,下一个循环的任务不会自动被激活. 为了解决这个问题,Org mode 通过如下方法来绕过这个限制:当你使用命令 C-c C-t 将任务标记为 DONE 时, 它会将时间戳信息改为下一个重复的时间. 然后将任务标记回为 TODO[fn:73].同时原时间戳会被复制并放在 deadline 的下一行处[fn:74],这样做的目的是保留一个记录告诉你,该任务其实是在上一个循环任务处完结后而来的. 举例来说,如果把上一个例子中的任务标记为 DONE,则该任务会变成:
	#+begin_src org
      , ** TODO Pay the rent
      ,   DEADLINE: <2005-11-01 Tue +1m>   
	#+end_src
	
	当使用`+1m`作为 repeater 时,循环日期的增加会严格第一个月一个月地进行. 这样的话,假设你连续三个月忘了付账单了,你再把这个任务标记为 DONE 后,这个任务的 deadline 只会增加一个月,因此该任务还是被认为是超期的. 另外,还有一些任务--比如说更换电池,它只需要你在最后一次完成任务的时间点之后开始计算重复时间间隔. 为了应付这些情况,Org mode 提供了另外两种 repeater:`++`和`.+`. 例如
	#+begin_src org
      ,** TODO Call Father
      ,   DEADLINE: <2008-02-10 Sun ++1w>
      ,   Marking this DONE will shift the date by at least one week,
      ,   but also by as many weeks as it takes to get this date into
      ,   the future.  However, it stays on a Sunday, even if you called
      ,   and marked it done on Saturday.
      ,** TODO Check the batteries in the smoke detectors
      ,   DEADLINE: <2005-11-01 Tue .+1m>
      ,   Marking this DONE will shift the date to one month after
      ,   today.
	#+end_src

	若你在某项任务上同时设置了最后期限和规划日期,请保持两者的 repater 间隔一致.

	另一种替代 repeater 的方法是创建一系列的任务拷贝,每隔拷贝使用不同的日期. 命令`C-c C-x c`可以实现这个功能,参见[[Structure editing][结构编辑]]
** 计时工作时间		   		   		    :跟踪你在一项任务上花了多少时间
   Org mode 可以帮助你记录下某项任务花了多少时间. 当你开始工作时,你可以打开计时功能. 当你停止工作或者标识该任务为 DONE 时,则停止计时并记录下相应的时间间隔. 它还能计算出每项任务所花的总共时间. 同时它还会记录下最近计时任务的历史,这样你可以在这些任务之间快速跳转.

   要在不同的 Emacs session 之间保存计时历史,使用如下配置
   #+begin_src elisp
     (setq org-clock-persist 'history)
     (org-clock-persistence-insinuate)
   #+end_src
   
   在恢复 Emacs 后,当你开始对一个新任务进行计时时,此时若有上次未完成的计时[fn:75],则会提示你如何处理,详见[[Resolving i][分辨空闲时间]]
*** 计时命令                             :开始/停止计时
	* C-c C-x C-i (org-clock-in)
	  开始对当前任务计时,该命令会插入 CLOCK 关键字和时间戳. 如果插入的 CLOCK 不是该任务的第一个计时记录,那么这些 CLOCK 记录都会放入一个名为`LOGBOOK`的 drawer 中(由变量`org-clock-into-drawer`设定). 你也可以通过设置`CLOCK_INTO_DRAWER`或`LOG_INTO_DRAWER`属性的方式来覆盖全局设置. 
	  若调用该命令时加了 C-u 前缀参数,则会让你从最近计时的几个任务中选择一个任务进行计时.
	  若调用命令时加了两个 C-u 前缀参数,则会对光标所在的任务开始计时,并把该任务设置为默认任务. 设置为默认任务后,使用 C-u 前缀参数调用命令时,可以用 d 来进行选择.
	  
	  当计时开始后,mode-line 上会显示任务及子任务总计所花的时间和正在计时的任务标题. 如果正在进行的任务需要进行效用评估[[#Effort estimates][参见章节 Effort estimates]]. mode-line 上会同时显示预计时间和实际时间[fn:76].  如果任务是重复任务[[#Repeated tasks][参见章节 Repeated tasks]]. 则计时只从最后一次重复开始算起[fn:77]. 要进一步控制显示在 mode-line 上的时间,可以配置属性`CLOCK_MODELINE_TOTAL`. 该属性的值为`current`标示只显示当前的计时实例,值为`today`则显示今天所有任务的统计信息(也可以参见变量`org-extend-today-until`),属性值为`all`则统计所有的计时信息,该属性默认值为`auto`[fn:78].

	  在 mode-line 上点击鼠标左键,会弹出计时选项相关的菜单

	* C-c C-x C-o (org-clock-out)
	  结束计时. 该命令会在计时开始的那一行插入另一个时间戳并自动计算所花费的时间,然后以`=>HH:MM`的形式插入到两个时间戳之间. 通过配置变量`org-log-note-clock-out`可以在记录 clock-out 时间戳的同时记录其他附加信息.[fn:79]

	* C-c C-x C-e (org-clock-modify-effort-estimate)
	  更新当前计时任务的效用评估信息

	* C-c C-c / C-c C-y (org-evaluate-time-range)
	  更改时间戳之后重新计算时间间隔. 该命令只在手工修改了时间戳的时候才有用. 如果你用 S-<cursor>来更改时间戳,会自动更新时间间隔.

	* C-S-<up/down> (org-clock-timestamps-up/down)
	  同步增加/减少 CLOCK 行的结束和开始的时间戳,保持时间段不变

	* C-c C-t (org-todo)
	  改变正在计时的任务为完成状态会自动停止计时

	* C-c C-x C-x (org-clock-cancel)
	  取消当前计时

	* C-c C-x C-d (org-clock-display)
	  展示当前 buffer 中所有子树的计时统计信息. 该命令会在每隔标题的后面添加上总计的计时时间,每隔总计时间等于该标题下各子标题的总计时间之和. 当你切换到其他 buffer(参见变量`org-remove-highlights-with-change`)或按下`C-c C-c`后,该总计时间就会消失

	在 timeline(参见章节[[#Timeline for a single file][Timeline for a single file]])和 agenda(参见章节[[#The weekly/daily agenda][The weekly/daily agenda]])模式下,按下`l`键可以查看当天做过哪些任务或者哪些任务今天结束了.
*** 计时报告                              :详细报告
	Org-mode 可以基于计时信息统计出复杂的报表,这种报表是以 Org 表格的形式展示的,因此也叫做 clock table
	* C-c C-x C-r (org-clock-report)
	  在当前文件插入一个 dynamic block,内涵一个 clock report. 如果执行命令时光标位于一个已经存在的 clock table 内,则更新该 clock table. 如果执行该命令时带了个前缀参数,则跳到第一个 clock report 并更新之. The clock table always includes also trees with :ARCHIVE: tag
	* C-c / C-c C-x C-u (org-dblock-update)
	  更新光标所在的 dynamic block. 光标需要位于 dynamic block 的#+BEGIN 这一行
	* C-u C-c C-x C-u
	  更新所有的 dynamic blocks. 如果在 buffer 中有多个 clock table block,则该命令非常有用.
	* S-<left> /S-<right> (org-clocktable-try-shift)
	  更改当前 clock table 的:block 参数并更新之. 执行该命令时光标需要处于#+BEGIN: clocktable 这一行. 如果:block 是`today`,则会切到`today-1`,依次类推.

	下面是一个 clock table 的框架
	#+begin_src org
      ,#+BEGIN: clocktable :maxlevel 2 :emphasize nil :scope file
      ,#+END: clocktable
      
	#+end_src
	BEGIN 行及后面一系列的选项定义了范围,结构和报告的格式. 这些选项的默认值可以通过变量`org-clocktable-defaults`来配置.

	第一类选项决定了哪些 clock entry 会被选入统计
	#+begin_quote
: maxlevel    Maximum level depth to which times are listed in the table.
:              Clocks at deeper levels will be summed into the upper level.
: scope       The scope to consider.  This can be any of the following:
:              nil        the current buffer or narrowed region
:              file       the full current buffer
:              subtree    the subtree where the clocktable is located
:              treeN      the surrounding level N tree, for example tree3
:              tree       the surrounding level 1 tree
:              agenda     all agenda files
:              ("file"..) scan these files
:              file-with-archives    current file and its archives
:              agenda-with-archives  all agenda files, including archives
: block       The time block to consider.  This block is specified either
:              absolute, or relative to the current time and may be any of
:              these formats:
:              2007-12-31    New year eve 2007
:              2007-12       December 2007
:              2007-W50      ISO-week 50 in 2007
:              2007-Q2       2nd quarter in 2007
:              2007          the year 2007
:              today, yesterday, today-N          a relative day
:              thisweek, lastweek, thisweek-N     a relative week
:              thismonth, lastmonth, thismonth-N  a relative month
:              thisyear, lastyear, thisyear-N     a relative year
:              Use S-<left>/<right> keys to shift the time interval.
: tstart      A time string specifying when to start considering times.
: tend        A time string specifying when to stop considering times.
: step        week or day, to split the table into chunks.
:              To use this, :block or :tstart, :tend are needed.
: stepskip0   Do not show steps that have zero time.
: fileskip0   Do not show table sections from files which did not contribute.
: tags        A tags match to select entries that should contribute.  See
:              Matching tags and properties for the match syntax.
:   
	#+end_quote
	
	第二类选项指定了 table 的展示形式. 这些选项默认由函数`org-clocktable-write-default`解释,但是我们也可以使用`:formatter`参数来指定由我们自定义的函数来解释
	#+begin_quote
: :emphasize   When t, emphasize level one and level two items.
: :lang        Language(80) to use for descriptive cells like "Task".
: :link        Link the item headlines in the table to their origins.
: :narrow      An integer to limit the width of the headline column in
:              the org table.  If you write it like ‘50!’, then the
:              headline will also be shortened in export.
: :indent      Indent each headline field according to its level.
: :tcolumns    Number of columns to be used for times.  If this is smaller
:              than :maxlevel, lower levels will be lumped into one column.
: :level       Should a level number column be included?
: :compact     Abbreviation for :level nil :indent t :narrow 40! :tcolumns 1
:              All are overwritten except if there is an explicit :narrow
: :timestamp   A timestamp for the entry, when available.  Look for SCHEDULED,
:              DEADLINE, TIMESTAMP and TIMESTAMP_IA, in this order.
: :properties  List of properties that should be shown in the table.  Each
:              property will get its own column.
: :inherit-props When this flag is t, the values for :properties will be inherited.
: :formula     Content of a #+TBLFM line to be added and evaluated.
:              As a special case, ‘:formula %’ adds a column with % time.
:              If you do not specify a formula here, any existing formula
:              below the clock table will survive updates and be evaluated.
: :formatter   A function to format clock data and insert it into the buffer.
: 
	#+end_quote
	
	要得到当天中当前 level 1 tree 的计时总计信息,你可以这样写
	#+begin_src org
      ,#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
      ,#+END: clocktable   
	#+end_src

	要统计指定的时间段的信息,则可以这样写
	#+begin_src org
      ,#+BEGIN: clocktable :tstart "<2006-08-10 Thu 10:00>"
      ,                    :tend "<2006-08-10 Thu 12:00>"
      ,#+END: clocktable
      ,   
	#+end_src

	要水平地以紧凑模式来展示至上个星期以来的计时统计,可以这样写
	#+begin_src org
      ,#+BEGIN: clocktable :scope agenda :block lastweek :compact t
      ,#+END: clocktable
      ,   
	#+end_src
*** 识别空闲时间                          :识别出你未做工作的空闲时间
	
** 效果评估		   		   		   		:提前规划工作成果
** 记笔记的同时打开计时器		 		    :带计时器的笔记
** 倒计时计时器		   		   		    :为任务倒计时
* Footnotes

[fn:1] install-info 的输出也是系统依赖的. 在特定的 Debian 及其衍生系统中使用两种不同版本的 install-info 程序.如果你看到
  #+BEGIN_EXAMPLE
    This is not dpkg install-info anymore, but GNU install-info
    See the man page for ginstall-info for command line arguments  
  #+END_EXAMPLE
  只管忽略它就好.

[fn:2] 如果你不想在全局范围使用 font-lock,你可以用下面一句配置来只在 Org-mode 下打开 font-lock 选项
  #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'turn-on-font-lock) 
  #+END_SRC

[fn:3] 请考虑订阅邮件列表，以减少工作邮件列表版主的工作量。

[fn:4] 要配置 C-a,C-e 和标题环境中 C-k 的行为,参见参数'org-special-ctrl-a/e', 'org-special-ctrl-k 和'org-ctrl-k-protect-subtree'

[fn:5] 参见 org-cycle-emulate-tab 选项

[fn:6] 参见 org-cycle-global-at-bob 选项

[fn:7] indirect buffer(关于 indirect buffer 的更多信息请查看 Emacs 手册)仅仅包含了原 buffer 中当前树的内容. 编辑这个 indirect buffer 也会修改原 buffer,但是对原 buffer 的可见性不会有影响

[fn:8] 如果你不想一行内容被分割,你需要定制变量'org-M-RET-may-split-line'

[fn:9] 参见变量'org-show-hierarchy-above','org-show-following-heading','org-show-siblings'和'org-show-entry-below',这些参数详细定义了每次匹配多少内容

[fn:10] 这种行为依赖于'org-remove-highlights-with-change'选项

[fn:11] 这种方法在 Xemacs 中是行不通的,because XEmacs uses selective display for outlining, not text properties. 

[fn:12] 当使用*作为列表项的标志时,这一行必须是有缩进的,否则它们会被认为是顶层的标题. 同样的道理,如果你为了得到一个干净的大纲视图而隐藏了前面的星星,那么以*开头的列表项和真正的标题之间会很难区分. 总之,即使支持'*'作为列表项标志,但最好还是不要用它.

[fn:13] 你可以通过配置'org-plain-list-ordered-item-terminator'来过滤掉它们中的任何一个.

[fn:14] 通过配置'org-alphabetical-lists',你也可以用类似'a.','A.','a)','A)'作为列表项的标志. 为了最小化与普通文档的混淆,只准使用单个字符作为标志. 超过这个限制,列表项标志会自动变回数字.

[fn:15] 如果列表项中包含有复选框,那么这种标志必须放在复选框的前面. 如果你激活了字母列表,你也可以使用类似[@b]这样的形式.

[fn:16] 参见'org-empty-line-terminates-plain-lists'

[fn:17] Org 只会改变 Emacs 的 filling 设置,对于 XEmacs,你应该是 i 用 Kyle E.Jones 的'filladapt.el'.为了启用这个包,在'.emacs'中添加'(require 'filladapt)'

[fn:18] 如果你不想分割列表项,自定义变量'org-M-RET-may-split-line'

[fn:19] 如果你想用这种方式遍历列表项,你可能需要自定义'org-list-use-circular-motion'

[fn:20] 循环行为参见'org-liste-use-circular-motion'

[fn:21] 欲了解列表项标志的更多规则,参见'org-list-automatic-rules'

[fn:22] 你可以在每个文件中定义 drawers,方法为添加一行类似'#DRAWERS: HIDDEN PROPERTIES STATE'这样的一行.

[fn:23] 相应的 in-buffer 设置为: '#+STARTUP: fninline'或者'#+STARTUP nofninline'

[fn:24] 相应的 in-buffer 设置为: 'fnadjust' 和 'nofnadjust'.

[fn:25] 要插入一个竖线到表格域中,使用\ vert(去掉空格)代替,若要插入竖线到单词中,则用\ vert{}(去掉空格)代替,例如 abc\vert{}def.

[fn:26] 这个特征在 XEmacs 上无效

[fn:27] 诚然它在 Emacs 中是无效的,但是它在导出为 HTML 使却有效.

[fn:28] Org 能够识别用户使用'B4'这种写法,但是当 Org 提供公式来编辑时,不会采用这种引用的表示法. 你可以使用变量'org-table-use-stand-references'来定制这种行为.

[fn:29] 为了向后兼容性,你可以使用特定的名称类似$LR5 和$LR12,分别引用的是表格的倒数第 5 和倒数第 12 行. 然而,现在这种语法已经被弃用, 在新文档中不应该再使用这种语法了,现在使用@>$代替.

[fn:30] 这种操作所花时间的时间复杂度为 O(N^2),因为表格 FOO 需要首先被解析一边这样每一行才能被拷贝过来.

[fn:31] 'constants.el'通过两种单位系统来提供常量值,分别是 SI 和 cgs. 具体使用哪个单位系统取决于变量'constants-unit-system'的设置. 你也可以通过#+STARTUP 选项中的 constSI 和 constcgs 来为某个文件设置该属性的值.

[fn:32] 使用 printf 进行重新格式化时,精度的指定是收到限制的.这是因为,传给 printf 的值会自动被转换为 integer 或 double 类型. integer 型数字被限制为包括符号位一共 32bit,超过就会被截断. 而 double 型被限制为精度为 64 位其中保留 16 位小数(leaves approximately 16 significant decimal digits)

[fn:33] 这里名字必须是以字母数字开头,并且只使用字母数字和下划线

[fn:34] 注意:在第一个标题前的文本通常是不会导出的,因此第一个这种链接吊臂应该是在第一个标题之后的,或者在第一个标题前但是与第一个标题是同一行的位置.

[fn:35] 当要插入一个连接到标题的链接时,可以使用 in-buffer 补完功能. 只需要输入一个星号(*)随后跟着几个可选的字母,然后按下 M-<TAB>, 当前 buffer 中所有的标题都会作为补完的选项显示出来.

[fn:36] 搜索的实际行为依赖于变量'org-link-search-must-match-exact-headline'的值. 如果该值为 nil 则执行模糊查询. 如果该值为 t,则精确匹配标题. 如果该值为'query-to-create'则精确匹配标题,但若匹配不到,则创建一个新标题.

[fn:37] 如果标题中含有时间戳,时间戳部分不会包含在链接中,从而导致一个错误的链接,因此,最好不要在标题中放置时间戳

[fn:38] 你不是一定要用这个命令才能插入链接. Org 中的链接其实只是个纯文本而已, 你可以直接在 buffer 中输入或者复制这些文本. 使用这个命令,链接自动被双方括号括住,随后你需要输入可选的描述信息

[fn:39] 把存储的链接插入 buffer 之后,这个链接会从存储链接的列表中移走. 如果你希望插入链接之后,链接还保存在列表中,你可以使用`c-u c-u c-u c-c c-l`或者配置选项`org-keep-stored-link-after-insertion`

[fn:40] 这是通过`org-PREFIX-complete-link`这个函数来实现的

[fn:41] 参见变量`org-display-internal-link-with-indirect-buffer`

[fn:42] 对应#+STARTUP 中的关键字`inlineimages`

[fn:43] 为了向后兼容,当附加信息为行号时,也可以使用单冒号(:)

[fn:44] 当然,你可以创建一个只包含 TODO 事项列表的文档,但这并不是必须的

[fn:45] 改变这个变量之后,需要重启 Org mode 才能生效

[fn:46] 这一点对于 timeline 和 agenda 缓存区中的 t 命令也适合

[fn:47] 如果你不想区分 tag 和 todo 状态的话,通过配置变量`org-fast-tag-selection-include-todo`可以让你在改变 tag 的时候自动改变 TODO 状态(参见章节[[#Setting tags][设置 tag]]).注意,这意味着你需要为两组关键字分配相同的快捷键

[fn:48] Org-mode 只在读入文件的时候才会去解析这些配置行. 在以`#+`开头的行按下`C-c C-c`的作用是为当前 buffer 重启一次 Org-mode

[fn:49] 对应的文件内设置是#+STARTUP: logdone

[fn:50] 对应的文件内设置是#+STARTUP: lognotedone

[fn:51] 参见变量`org-log-states-order-reversed`

[fn:52] 当你设置了 STARTUP 参数`org-log-done`,同时又为状态设置了记录动作的时候,就有可能出现连续记录了两次时间戳的情况. 然而,即使你两边都配置了记录附加信息的动作,org 也不会提示你输入两次附加信息.为状态单独设置的记录动作会优先执行.

[fn:53] 另见选项`org-priority-start-cycle-with-default`

[fn:54] 如果你希望全局的 TODO 列表中不现实子任务,参见`org-agenda-todo-list-sublevels`

[fn:55] 默认不包括描述列表在内. 但是通过修改`org-list-automatic-rules`你也可以允许描述列表成为 checkbox

[fn:56] 如果你希望统计的时候统计所有层次的下级 checkbox 而不仅仅是直接子 checkbox,那你需要修改变量`org-hierarchical-checkbox-statistics`

[fn:57] 如果在列表的第一行使用`C-u C-c C-c`,而刚好这一行事项没有 checkbox 标识. 则会给该列表所有事项都加上 checkbox 的标识

[fn:58] 就跟其他文件内设置一样,按`C-c C-c`使这行设置生效

[fn:59] 只有在搜索不涉及到包括属性在内的复杂匹配模式的情况下才成立

[fn:60] 如果 tag 没有明确配置快捷键,那么 org 会自动給它们分配快捷键

[fn:61] 注意,在定义 COLUMN 格式时,必须写在同一行中

[fn:62] 也就是说它不属于 Emacs 内置的一部分(访问 http://orgmode.org)

[fn:63] 当你手工输入时间戳时,星期不是必须的. 但若你是用 Org 命令来修改或插入时间戳,则会自动插入星期,这样更方便一些

[fn:64] 这里准照的是 ISO8601 日期/时间规范. 若要采用其他规范,参见[[Custom time format][定制时间规范]]

[fn:65] 当使用这种 diary 风格的类 lisp 表达式时,你需要非常小心检查这些参数的调用顺序. 这种顺序严重依赖于变量`calendar-date-style`(对旧版本的 Emacs 来说是`european-calendar-style`). 例如要指定日期`2005 年 12 月 12 日`,根据不同的设置分别可以用`(diary-date 12 1 2005)`,`(diary-date 1 12 2005)`,`(diary-date 2005 12 1)`来表示. 这常常让人很疑惑. 用户可以求助于某些特定函数,例如`org-date`或`org-anniversary`. 这些函数跟那些以`diary-`打头的 diary 函数功能上差不多,但他们的参数使用的是固定的 ISO 顺序(年,月,日的顺序)而与`calendar-date-style`的值无关

[fn:66] 参见变量`org-read-date-prefer-future`. 你可以通过设置该值为符号`time`(也就是`'time`),这样之后可以让 Org-mode 当前时间之前的时间说明当成是明天的时间.

[fn:67] 如果你不想要 calendar 出现,配置变量`org-popup-calendar-for-date-prompt`

[fn:68] 如果你觉得这会让你分心,通过配置`org-read-date-display-live`来打开/关闭这种显示

[fn:69] 它会一直显示,即使本标记为完成状态还是会显示. 如果你不想这样,设置变量`org-agenda-skip-scheduled-if-done`

[fn:70] 最后期限和规划日期放置的为止需要紧跟在表示任务的标题行之下. 不要在中间插入任何其他内容.

[fn:71] 相对应的#+STARTUP 关键字有 logredeadline, lognoteredeadline, 和 nologredeadline 

[fn:72] 相对应的#+STARTUP 关键字有 logreschedule, lognotereschedule, 和 nologreschedule

[fn:73] 事实上任务变回的目标状态由一下流程决定:先取属性`REPEAT_TO_STATE`的值,然后取变量` org-todo-repeat-to-state`的值,若都取不到,则默认为 TODO 状态序列的第一个状态

[fn:74] 你可以通过更改变量`org-log-repeat`的值来更改这种行为模式,或者设置#+STARTUP 选项为 logrepeat,lognoterepeat 和 nologrepeat 中的其中一个. 若设置为 lognoterepeat,则你会被提示输入记录内容.

[fn:75] 若希望 Emacs 假设你在这段时间内依然是在做这项任务,使用配置(setq org-clock-persist t)

[fn:76] 要实现自动进行效用评估,为`org-clock-in-prepare-hook`增加 hook 函数来实现效用评估

[fn:77] 该时间同时由属性`LAST_REPEAT`持有

[fn:78] 参见变量`org-clock-modeline-total`

[fn:79] 对应的单文件设置为` #+STARTUP: lognoteclock-out `





