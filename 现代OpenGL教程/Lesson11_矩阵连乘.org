* 第十一课 矩阵连乘
** 背景
- 在前几章中我们学习了一些变换，通过它们我们能将3D世界中的物体灵活的变换到任意位置。之后我们还要学习两个变换（相机控制和透视投影），但是正如你可能已经猜到的，我们需要一个变换的组合。在很多情况下，你需要缩放物体以适应你的 3D 世界的尺寸，将其旋转到需要的方向，平移到某处等等。直到现在，我们每次都只能使用一个单一的变换。为了实现上述一系列的变换，我们需要用顶点坐标与第一个变换矩阵相乘，然后将前面的结果与下一个的变换矩阵相乘。如此持续到所有的变换矩阵都应用到顶点上面。要实现这个效果，最简单的办法就是向着色器提供所有的变换矩阵并依次让他们做相乘运算。然而，这种方法非常低效，因为对于顶点来说所有的变换矩阵都是一样的，而改变的只是顶点的位置而已。
- 幸运的是，线性代数提供了一套规则使得我们的处理变得简单。这个规则告诉我们，给定一组矩阵 M0...Mn 和一个向量 V，以下式子恒成立：
- *Mn Mn-1 ... M0 V = (Mn Mn-1 ... M0) V*
- 所以如果我们计算：
- *N = Mn Mn-1 ... * M0*
- 然后：
- *Mn Mn-1 ... M0 V = N * V*
- 这意味着我们可以直接将 N 计算出来，然后将其作为一致变量传递到着色器和每个顶点相乘。这就要求 GPU 对每个顶点只进行一次矩阵或者向量的相乘。
- 当我们生成 N 时你是怎么安排矩阵相乘的顺序的？需要注意的是向量会首先和最右边的矩阵相乘（本例中是M0）。然后从右向左，向量依次被每个矩阵变换。在3D图形中，你常常会希望先缩放物体然后旋转、平移，然后应用相机变换，最后经过透视投影变换到2D屏幕上。让我们看看如果你先旋转再平移这会发生什么：
- [[111.jpg
- 现在我们再看看先平移再旋转发生了什么:
- [[112.jpg
- 正如你看到的，在世界坐标系中，当你先平移物体后很难设置它的位置，因为如果你将其从原点移开然后再旋转，它会围绕着原点旋转，这实际上相当于你再次平移了这个物体。一般情况下，你都不会想出现这样的二次平移，所以我们可以通过先旋转然后平移的方法，断开这两种操作的依赖关系。这就是为什么建模应围绕原点并且越对称越好。这样当你缩放或者旋转物体时都没有副作用，而且被旋转或缩放的物体仍然会保持对称。
- 既然我们已经开始处理多个矩阵的变换，那么我们最好扔掉直接在渲染函数中更新矩阵的习惯，这个方法效果不怎么好还容易出错。取而代之我们引入了管线类。在这个类中我们使用一个简单的 API 来封装平移、旋转以及缩放矩阵的运算的具体细节。在设置了其内部所有的参数后，我们可以获得多个矩阵运算的最后结果矩阵。这个矩阵可直接被送到着色器中。
